---
html:
  offline: true
export_on_save:
  html: true
---

<div class="cover">
  <img src="https://picbed.huaier-ashgrey.top/image/image-2.webp">
</div>

<br>

# C++基础知识笔记

<br>

<br>

<br>

## 1 C++基础

<br>

### 1.1 C++引入

<br>

C++对大小写敏感，文件拓展名`.cpp`是一种表示C++程序的常用方式。一个C++源代码的例子如下：

``` cpp
#include <iostream>
int main() {
    using namespace std;
    cout << "I love sagiri!";
    cout << endl;
    cout << "Sagiri is a bishojo.";
    cout << endl;
    cin.get();
    return 0;
}
```

C++能够使用`printf()`、`scanf()`和其他所有标准C输入和输出函数，只需要包括常规C语言的`stdio.h`文件。通常，C++先将程序组织为主要任务，然后独立设计的函数来处理这些任务。上述程序只包括`main()`函数。

上述程序包括：

- 注释由前缀`//`标识
- 预处理器编译指令`#include`
- 函数头`int main()`
- 编译指令`using namespace`
- 函数体，用`{}`括起，体内所有语句都应以分号结束，否则会编译错误
- 使用C++的`cout`工具显示消息的语句
- 结束`main()`函数的`return`语句

#### 1.1.1 `main()`函数

通常C++函数可被其他函数激活或调用，函数头描述了函数与调用它的函数之间的接口。位于函数名前面的部分称为**函数返回类型**，描述的是从函数返回给调用它的函数的信息。函数名后括号中的部分称为**形参列表**或**参数列表**，描述的是从调用函数传递给调用的函数的信息。一般来说不会在其他函数内调用`main()`函数。

对于`int main()`语句，`int`意味着该函数返回整数值，空括号`()`意味着`main()`函数不接受调用它的函数的任何信息或者任何参数，也可以使用如下变体：

``` cpp
int main(void)
```

在C++中让括号空着与在括号中使用`void`等效，有些程序员使用如下的变体：

``` cpp
void main()
```

虽然这在逻辑上与前面的变体等价，这意味着函数不返回任何值，但是它不是当前标准强制的一个选项，因此在有些系统上是无法工作的。C++标准规定如果函数体内部没有`return 0;`的返回语句，则认为`main()`函数默认包含了该返回语句。这条隐含的返回语句只适用于`main()`函数，而不适用于其他函数。

C++程序必须包含一个`main()`的函数，名称是不得变更的。在有些情况下，可以不使用`main()`函数。

#### 1.1.2 C++注释

使用双斜杠`//`开头，到行尾结束，双斜杠的注释只能包括一行。如果需要使用多行注释，可以使用C风格的注释，包括在`/*`与`*/`之间。

#### 1.1.3 C++预处理器和`iostream`文件

程序使用C++输入或输出工具应提供这样两行代码：

``` cpp
#include <iostream>
using namespace std;
```

该编译指令导致预处理器将`iostream`文件的内容添加到程序中，典型的预处理器操作是这样的：在源代码被编译前，替换或者添加文本。C++的输入输出方案涉及`iostream`文件中的多个定义。为了使用`cout`来显示信息，程序需要使用这些定义。`#include`编译指令导`iostream`文件的内容取代程序中的代码行`#include<iostream>`。原始文件没有改变，而是将源代码文件和`iostream`组合成一个复合文件。编译的下一个阶段将使用该文件。

#### 1.1.4 头文件名

像`iostream`这样的文件称为**包含文件**或者**头文件**。C++编译器包括了这些头文件，C语言的传统是包含`.h`的扩展名的文件，例如头文件`math.h`支持各种C语言数学函数。C++对老式C的头文件保留了扩展名，但C++头文件则没有扩展名。有一些C头文件被转换为C++头文件，这些文件被重命名，去掉`.h`扩展名并在开头添加字母c表示文件来自传统C语言，例如`math.h`被改为`cmath`。

#### 1.1.5 名称空间

在使用`<iostream>`而不是`<iostream.h>`时，需要使用**名称空间**。名称空间是一项C++特性，它将类、函数和变量存储在同一个名称空间之下，使得可以调用某个名称空间下的某名称的类、函数或变量。例如名称空间`line`下的函数`alpha_quad()`可以表示为`line::alpha_quad()`，但是可能同时存在其他名称空间的同名的函数，例如`key`名称空间下的函数`alpha_quad()`可以表示为`key::alpha_quad()`。引入名称空间前使用的代码如下：

``` cpp
#include <iostream.h>
alpha_quad() {
    ...
}
```

当使用名称空间下的函数时，为满足不需要每次使用函数时都加上名称空间的需求，可以使用`using namespace line`这样的编译指令，代码如下：

``` cpp
#include <iostream>
using namespace line;
alpha_quad() {
    ...
}
```

当然也可以只使用名称空间中的某些函数，此后重复使用该函数时就不需要再写名称空间，代码如下：

``` cpp
#include <iostream>
using line::alpha_quad;
```

#### 1.1.6 使用`cout`进行C++输出

用双引号括起的一系列字符称为**字符串**。`<<`符号表示该语句将这个字符串发送给`cout`；该符号指出信息流动的路径。`cout`是一个预定义的对象，知道如何显示字符串、数字和单个字符等。

`endl`是一个特殊的C++符号，表示重起一行的概念。在输入流中插入`endl`将导致屏幕光标移到下一行开头。这种对于`cout`来说有特殊含义的特殊符号被称为**控制符**，和`cout`一样，`endl`也是在头文件`iostream`中定义的，且位于名称空间`std`中。

C++同样提供了旧有的换行方式：语言符号`\n`。代码如下：

``` cpp
cout << "I love sagiri!\n";
cout << "Sagiri is a bishojo";
```

<br>

### 1.2 C++语句

#### 1.2.1 声明语句和变量

必须指出信息的存储位置和所需的内存空间，C++使用**声明语句**来指出存储类型并提供位置标签，例如：

``` cpp
int carrots;
```

这条语句给计算机提供两条信息，`int`说明计算机要准备一个足够的空间用来存储一个整数（在C++里用`int`表示整数），编译器负责分配和标记内存的细节。`carrots`说明存储变量空间名称，此后程序将使用名称`carrots`来标识存储在该单元中的值。在C++中，**所有变量都需要声明**。程序中的声明语句一般是一个定义式的，称为**定义声明语句**，简称**定义**。在较为复杂的情况下，还有可能存在**引用声明语句**，该语句可以使用其他地方定义的变量。

对于变量声明的位置，C++没有太多限制，只需要在变量首次使用前声明即可，C++通常的做法是在首次使用变量前声明它，可以不把所有变量声明放在一个地方。

#### 1.2.2 赋值语句

``` cpp
carrots = 25;
```

赋值语句将值赋给存储单元，符号`=`称为赋值运算符，C和C++可以使用连续的赋值运算符，例如：

``` cpp
int line_alpha;
int drag_alpha;
int hold_alpha;
line_alpha = drag_alpha = hold_alpha = 255;
```

赋值运算将从右往左进行。可以使用赋值语句对变量的值进行更改：

``` cpp
hold_alpha = hold_alpha - 40;
```

赋值语句还可以使用`cin`进行外部输入。`iostream`文件定义`cin`为一个表示流入程序的字符流，输出时`<<`运算符将字符串插入到输出流中；输入时`cin`使用`>>`运算符从输入流中抽取字符，通常需要在运算符右侧提供变量以接受抽取的信息。

`cout`一项重要的特性是可以多个输出语句合并为一条，例如

``` cpp
cout << "I will always love sagiri," << "and I will die on the road to the top of Babel.";
```

也可以写成多行：

``` cpp
cout << "I will always love sagiri,"
     << "and I will die on the road to the top of Babel.";
```

<br>

### 1.3函数初步

<br>

#### 1.3.1 使用有返回值的函数

有返回值的函数在被调用时会产生一个值，这个值能用于数学计算或者赋值，例如“

``` cpp
x = sqrt(4);
```

其中`sqrt()`函数是标准库中的一个函数，它计算参数的平方根。表达式`sqrt(4)`被称为**函数调用**，被调用的函数`sqrt()`被称为**被调用函数**，包含函数调用这一过程的函数称为**调用函数**，圆括号内的数值被称为**参数**，函数返回得到的数值称为**返回值**

编译器需要知道函数的参数类型和返回值类型，C++提供这些信息的是**函数原型语句**。例如C++定义`sqrt()`函数时可以使用以下函数原型语句：

``` cpp
double sqrt(double);
```

括号中的`double`意味着该函数需要一个`double`参数，函数原型语句结尾的分号意味着它是一个原型而不是函数头。在程序中使用函数`sqrt()`时，必须提供原型，这可以用两种方式实现：

- 在源代码中输入函数原型；
- 包含头文件`cmath`，其中已经定义了`sqrt()`的原型

    ``` cpp
    #include <cmath>
    ```

#### 1.3.2 函数变体

当函数需要多个参数时，在函数原型语句中参数之间用逗号隔开。如数学函数`pow()`接受两个参数，返回值是以第一个参数为底，第二个参数为指数的幂。该函数的原型如下：

``` cpp
double pow(double, double);
```

也有一些函数是不接受任何参数的，例如与`cstdlib`和`stdlib.h`头文件相关的库中有一个函数`rand()`，它的原型如下：

``` cpp
int rand(void);
```

该函数不接受任何参数并且返回一个随机整数。当省略`void`参数时，C++会默认解释为一个不接受任何参数的隐式声明。

还有一些函数是没有返回值的，例如对变量的值进行交换，或者直接向屏幕输出内容，可以使用`void`制定函数返回值类型：

``` cpp
void exchange(double,double);
```

对于没有返回值的函数，不能将其用于赋值语句或者其他的表达式中，而是应该使用纯粹的函数调用语句，例如：

``` cpp
exchange(a,b);
```

#### 1.3.3 用户定义的函数

每个C++程序必须有`main()`函数，且用户必须对其进行定义。用户也可以使用函数原型语句定义新的函数，这些函数原型语句需要放在`main()`函数主体前，新定义的函数的内容放在`main()`函数主体之后，例如：

``` cpp
#include <iostream>

void exchange(double *, double *);

int main() {
    using namespace std;
    double a;
    double b;
    cin >> a;
    cin.get();
    cin >> b;
    cin.get();
    exchange(&a, &b);
    cout << a << " " << b;
    return 0;
}

void exchange(double *x, double *y) {
    double t;
    t = *x;
    *x = *y;
    *y = t;
}
```

函数的格式一般如下：

``` plaintext
type functioname(argumentlist) {
    statements
}
```
C++不允许将函数定义嵌套在另一个函数定义中，每个函数的定义都是独立的。其中`type functionname(argumentlist)`是函数头，`type`是函数返回值的类型，`functionname`是函数名，`argumentlist`是传递给函数的参数列表，`double *x`指调用函数时必须提供一个类型为`double`的参数，在这个函数体内部它被存储为`*x`。

#### 1.3.4 在多函数程序中使用`using`编译指令

``` cpp
#include <iostream>
using namespace std;
void sagiri_age(int n);

int main() {
    int year;
    cin >> year;
    cout << "In" << " " << year << ",";
    sagiri_age(year);
    cin.get();
}

void sagiri_age(int n) {
    int age;
    age = n - 2023 + 13;
    cout << "sagiri is" << " " << age << " " << "years old.";
}
```

在这个程序中，`using namespace std`指令在两个函数体之外，这是因为两个函数体内部都使用到了`cout`，所以给多个函数引入使用到的头文件，可以在函数体外部进行一次性的引用。

<br>

<br>

<br>

## 2 处理数据

<br>

### 2.1 简单变量

<br>

#### 2.1.1 变量名

C++的命名规则如下：

- 在名称中只能使用字母字符、数字和下划线`_`
- 名称的第一个字符不能是数字
- 区分大写字符和小写字符
- 不能使用C++关键字作为变量名称
- 以两个下划线`__`或下划线和大写字母开头的名称将保留给**实现**（编译器及其使用的资源的合称）使用，以一个下划线开头的名称被保留给实现，用作全局标识符
- C++对变量名称的长度没有限制

如果使用多个单词组成一个名称，最常用的方法是使用下划线将单词分隔开，如`line_alpha`和`drag_alpha`等，或者使用驼峰命名法。有些程序员会使用前缀`int`表示该变量为整数值，如`intMyWeight`等，常见的前缀包括`str`或`sz`（表示以空字符结尾的字符串）、`b`（表示布尔值）、`p`（表示指针）和`c`（表示单个字符）。

#### 2.1.2 整型

整数是没有小数部分的数字，计算机没有无限的内存，因此只能表示一定范围内的整数。C++提供多种整数类型，用**宽度**描述存储整数时使用的内存量，按照宽度递增的顺序排列C++提供的整型：`char`<`short`<`int`<`long`<`long long`，其中每种整型都具有**符号类型**（可以表示正负值）和**无符号类型**（不能表示负值）。

#### 2.1.3 整型`short`、`int`、`long`和`long long`

以上四种整型通过使用不同数目的位(`bit`)来表示整数，但是对于不同系统的计算机，其内存设计不同，所以C++只能保证不同整型的最低存储位数：

- `short`至少16位
- `int`至少与`short`一样长
- `long`至少32位，且至少与`int`一样长
- `long long`至少64位，且至少与`long`一样长

使用某个整型时，如果移植该程序到一些比较古老的系统中时可能会出现一些问题。对于16位的`int`类型，其取值范围是-32768到+32767。可以使用这些整型对变量进行定义：

``` cpp
short age;
int year;
long id_card;
```

头文件`<climits>`中包含了关于整型限制的信息，其定义了表示各种限制的符号名称，可以使用以下程序查看各种整型在用户计算机中的存储位数：

``` cpp
#include <iostream>
#include <climits>

int main() {
    using namespace std;
    int n_int_max = INT_MAX;                
    int n_int_min = INT_MIN;
    short n_short_max = SHRT_MAX;           
    short n_short_min = SHRT_MIN;
    long n_long_max = LONG_MAX;             
    long n_long_min = LONG_MIN;
    long long n_llong_max = LONG_LONG_MAX;  
    long long n_llong_min = LONG_LONG_MIN;

    cout << "The maxium of bytes of int is " 
         << sizeof(n_int_max) 
         << " bytes" 
         << endl;

    cout << "The minium of bytes of int is " 
         << sizeof(n_int_min) 
         << " bytes" 
         << endl;

    cout << "The maxium of bytes of short is " 
         << sizeof(n_short_max) 
         << " bytes" 
         << endl;

    cout << "The minium of bytes of short is " 
         << sizeof(n_short_min) 
         << " bytes" 
         << endl;

    cout << "The maxium of bytes of long is " 
         << sizeof(n_long_max) 
         << " bytes" 
         << endl;

    cout << "The minium of bytes of long is " 
         << sizeof(n_long_min) 
         << " bytes" 
         << endl;

    cout << "The maxium of bytes of long long is " 
         << sizeof(n_llong_max) 
         << " bytes" 
         << endl;

    cout << "The minium of bytes of long long is " 
         << sizeof(n_llong_min) 
         << " bytes" 
         << endl;

    cout << " " << endl;

    cout << "Maxium values:" << endl;
    cout << "int: " 
         << n_int_max 
         << endl;
    cout << "short: " 
         << n_short_max 
         << endl;
    cout << "long: " 
         << n_long_max 
         << endl;
    cout << "long long: " 
         << n_llong_max 
         << endl;

    cin.get();
    
    return 0;
}
```

在`windows11`系统中该结果的输出内容是：

``` plaintext
The maxium of bytes of int is 4 bytes
The minium of bytes of int is 4 bytes
The maxium of bytes of short is 2 bytes
The minium of bytes of short is 2 bytes
The maxium of bytes of long is 4 bytes
The minium of bytes of long is 4 bytes
The maxium of bytes of long long is 8 bytes
The minium of bytes of long long is 8 bytes

Maxium values:
int: 2147483647
short: 32767
long: 2147483647
long long: 9223372036854775807
```

运算符`sizeof`用于指出变量在计算机中所占的存储，在以上代码中，`int`的长度为4个字节。而且也可对变量名或者类型名使用该运算符，对类型名使用该运算符时必须使用括号：`sizeof(int)`，对变量使用该运算符时可以不使用括号：`sizeof n_int_max`。

**初始化**将赋值与声明合并在一起，例如：`int n_int_max = INT_MAX`。同样可以用字面值常量来初始化，也可以使用另一个变量进行初始化，前提是这个变量已经被定义过了。还可以使用表达式来初始化，前提是当代码执行到该语句时，表达式中所有变量的值都是已知的。

如果不对变量进行初始化，则该变量的值是该存储单元上在它被创建之前的值。初始化变量还有其他方法，如：

``` cpp
int line_alpha (255);
int drag_alpha {240};
int hold_alpha = {233};
```

当大括号内没有内容时，变量初始化为0。

#### 2.1.4 无符号类型

2.1.3中介绍的四种整型都有对应的无符号类型，无符号的整型的非负整数范围是符号类型的两倍。要使用无符号类型的，只需要在关键字`unsigned`修改声明：`unsigned int line_alpha`。

对于C++，整型变量如果超过了限制，其值将取范围另一端的取值。一般来说程序中最自然地选择整型；如果变量的值只有可能为正（例如文档字数），可以选用无符号类型；如果知道表示的变量的值可能超过16位整数（32767），则应该使用`long`，以防移植到16位系统时程序出错；如果变量值超过20亿，则应使用`long long`整型；仅当有大型整数数组时，才有必要使用`short`类型。

#### 2.1.5 整型字面量

C++能够以三种不同的计数方式书写整数，这三种计数方式都是在前一或两位标识数字常量的基数：如果第一位是1~9，则表示十进制；如果第一位是0，其余位是1~7的数字，则表示八进制；如果前两位是0x或0X，则表示十六进制。在默认情况下`cout`输出十进制数，可以控制它输出八进制、十进制和十六进制数：

``` cpp
cout << hex; // 16-based
cout << oct; //  8-based
cout << dec; // 10-based
```

在修改输出进制之前，原来的格式一直有效。

对于整型变量，其整型类型是由用户输入的声明语句决定的。而对于表达式中出现的常量，编译器能自动识别常量应该存储的类型。一般地，除非有理由将常量存储为其他类型（如带有特殊的后缀表示特定的类型，或者值太大），否则C++将整型常量存储为`int`类型。后缀是放在数字常量后面的字母，用来表示特定的整型。

- `l`或`L`后缀表示该整数为`long`常量（一般用大写，小写容易和1搞混）
- `u`或`U`后缀表示该整数为`unsigned int`常量
- `ll`或`LL`后缀表示该整数为`long long`常量

在C++中，对不带后缀的十进制整数，将使用`int`、`long`和`long long`中能存储该数的最小类型表示；对不带后缀的八进制或十六进制整数，将使用`int`、`unsigned int`、`long`、`unsigned long`、`long long`和`unsigned long long`中能存储该数的最小类型表示。

#### 2.1.6 `char`类型：字符和小整数

`char`类型能够表示目标计算机系统中的所有基本符号（字母、数字符号、标点符号等）。`char`类型可以存储一个输入的符号，也可以存储较小的数字。

``` cpp
#include <iostream>
#include <string>

int main() {
    using namespace std;
    
    char ch;
    cout << "Enter a character:";
    cin >> ch;
    cout << "The character you enter is:" << ch;
    return 0;
}
```

`char`类型的变量`ch`并没有存储用户输入的符号，而是存储了它在字符集中的位置（一般是ASCII）其被存储到内存中的过程是这样的：输入时，`cin`将键盘输入的字符转化为其在用户计算机中使用的字符集（如ASCII、Unicode）的序号。在这个程序中，经由`cout`输出的是符号。如果变量`ch`的类型是`int`，则经由`cout`输出的会是这个**序号本身**。

`cout`还具有一种特性：`cout.put()`函数用于显示一个字符。该函数实际就是C++ OOP的重要概念**成员函数**的一个例子：类定义如何表示和控制数据，成员函数归类所有并描述了操纵类数据的方法。在这里，类`ostream`有一个`put()`成员函数，用于输出字符，只能通过类的成员对象（这里是`cout`）使用成员函数，必须用句点将对象名和函数名称连接起来。句点称为**成员运算符**

有一些符号不能作为`char`类型的字面值：回车键不能键入换行符；双引号用于分隔字符串与程序语句，不能键入。对于这些字符，C++提供了转义序列：

|字符名称|ASCII符号|C++代码|十进制ASCII码|十六进制ASCII码|
|:---:|:---:|:---:|:---:|:---:|
|换行符|NL(LF)|`\n`|10|0xA|
|进纸符|FF/NP|`\f`|12|0xC|
|水平制表符|HT|`\t`|9|0x9|
|垂直制表符|VT|`\v`|11|0xB|
|退格|BS|`\b`|8|0x8|
|回车|CR|`\r`|13|0xD|
|振铃|BEL|`\a`|7|0x7|
|反斜杠|\ |`\\`|92|0x5c|
|问号|?|`\?`|63|0x3F|
|单引号|'|`\'`|39|0x27|
|双引号|"|`\"`|34|0x22|

也可以基于字符的八进制和十六进制编码来使用转义序列。例如`\063`与`\x3F`，但具体的编码序号取决于计算机的编码方式（我使用的中文`windows11`系统采用`CBK`编码，其顺序与`ASCII`码不同）。

`char`在默认情况下既不是没有符号的，也不是有符号的。是否有符号由C++实现决定，若`cahr`有某种特定的行为对用户来说很重要，可以设定为`signed char`和`unsigned char`类型。`char`类型也可以用作数值类型，`signed char`类型的表示范围是0~255，而`unsigned char`的表示范围是-128~127。

#### 2.1.7 新增的`wchar_t`整型、`char16_t`类型、`char32_t`类型

当C++程序需要处理的字符集可能无法使用一个八位的字节表示时，需要使用`wchar_t`类型的变量，该类型是一种整数类型，有足够的空间可以表示系统使用的最大扩展字符集。`cin`和`cout`将输入输出看作是`char`流，因此不能用来处理`wchar_t`整型，目前提供了两种工具`wcin`与`wcout`用于处理这种变量。可以通过在字符串前加上字母L表示宽字符常量和宽字符串。

在计算机系统上进行字符和字符串编辑时仅使用Unicode码点并不够开发人员使用，而类型`wchar_t`类型的长度随实现的变化而变化，故C++11标准提出了新的长度固定的两个可以表示字符的整型变量：`char16_t`（可以表示16位的字符）和`char32_t`（可以表示32位的字符）。C++11使用前缀`u`加字符串作为`char16_t`的字面值，使用前缀`U`加字符串作为`char32_t`的字面值。    

#### 2.1.8 `bool`类型

在计算中`bool`，即**布尔类型**的值可以是`true`或者`false`，C++将非零值解释为`true`，将零解释位`false`。

#### 2.1.9 字符函数库`cctype`

C++从C语言继承了用于判断字符是否为特定类型函数库`cctype`，其中包含用于判断是否为特定类型字符的函数：

|函数名称|返回值|
|---:|:---:|
|`isalnum()`|如果参数是字母或者数字，返回`true`|
|`isalpha()`|如果参数是字母，返回`true`|
|`iscntrl()`|如果参数是控制类字符（如`\n`和`\t`等），返回`true`|
|`isdigit()`|如果参数是十进制0到9之间的数字，返回`true`|
|`isxdigit()`|如果参数是十六进制0到9、a到f、A到F之间的数字，返回`true`
|`isgraph()`|如果参数是除空格以外的打印字符，返回`true`|
|`islower()`|如果参数是小写字母，返回`true`|
|`isupper()`|如果参数是大写字母，返回`true`|
|`isprint()`|如果参数是打印字符，返回`true`|
|`ispunct()`|如果参数是标点符号，返回`true`|
|`isspace()`|如果参数是标准空白字符（空格、换行符、回车、水平制表符、垂直制表符和进纸符），返回`true`|
|`tolower()`|如果参数是大写字母字符，则返回其对应的小写字母，否则返回原先的字符|
|`toupper()`|如果参数是小写字母字符，则返回其对应的大写字母，否则返回原先的字符|

<br>

### 2.2 `const`限定符

<br>

创建常量的通用格式如下：

``` plaintext
const type name = value;
```

常见的常量的命名方法是将首字母大写或者将整个常量名称都大写。`const`要比`#define`好，它不仅能够明确指定常量的类型，还可以使用C++的作用域规则将定义限制在特定的函数或者文件中，还可以用于指定更加复杂的类型。

<br>

### 2.3 浮点数

<br>

对于数字34.1245和3412.45，除了小数点位置不同外其他都是相同的，第一个数可以表示为`0.341245*10^2`，第二个数可以表示为`0.341245*10^4`，这里的`10^x`为**缩放因子**。C++内部表示浮点数的方法与此类似，不过其基于二进制，因此缩放因子是2的幂次而不是10的幂次。

#### 2.3.1 书写浮点数

C++的浮点数书写方式有两种：第一种是标准小数表示，第二种是E表示法

``` cpp
float a = 12.345;
float b = 13.00;
float c = 2.52e+8;
float d = 8.33E-4;
```

小数表示法中即使小数部分全为0，只要有小数点出现，C++就将其存为浮点数。E表示法中`Ex`或`ex`指的是十的幂次`10^x`（即为科学计数法）。对于`a.bcdE+f`这样的数，`E+f`的作用是将小数点进行右移，`E-f`表示将小数点进行左移，因此浮点数的含义是移动小数点。

#### 2.3.2 浮点类型

C++有三种浮点类型：`float`、`double`和`long double`。有效位指浮点数中有意义的位数，一切非零数位都是有意义的位。C/C++对于有效位数的要求是：`float`至少32位，`double`至少48位且不少于`float`，`long double`至少和`double`一样多。不过通常情况下，`float`为32位，`double`为64位，`long double`为80位、96位或128位，且三个类型的指数范围都至少是-37~37。

但是要注意`float`只能保证六位有效数值，如果需要更加精确的值需要使用`double`或者`long double`。

使用`cout`输出浮点数时会删除结尾的0，调用`cout.setf()`将覆盖这种行为。

``` cpp
#include <iostream>
int main() {
    using namespace std;
    cout.setf(ios_base::fixed, ios_base::floatfield);
    float float_number = 10.0 / 3.0;
    double double_number = 10.0 / 3.0;
    const float times_million = 1.0e6;

    cout << "float_number = " 
         << float_number 
         << endl;
    cout << "a million float_numbers =  " 
         << times_million * float_number 
         << endl;
    cout << "and ten million float_numbers =  " 
         << 10 * times_million * float_number 
         << endl;
    cout << "double_number = " 
         << double_number 
         << endl;
    cout << "a million double_numbers =  " 
         << times_million * double_number 
         << endl;
    cout << "and ten million double_numbers =  " 
         << 10 * times_million * double_number 
         << endl;
}
```

程序在终端的输出结果为：

``` plaintext
float_number = 3.333333
a million float_numbers =  3333333.250000
and ten million float_numbers =  33333332.000000
double_number = 3.333333
a million double_numbers =  3333333.333333
and ten million double_numbers =  33333333.333333
```

通常`cout`会删除结尾的零，调用`cout.setf()`将覆盖这种行为。默认情况下，定义的常量是`double`类型的，如果希望常量为`float`类型，应当在常量后面写上后缀`f`或`F`，如果希望常量是`long double`类型的，应当在常量后面写上后缀`l`或`L`。

<br>

### 2.4 C++算术运算符

<br>

- `+`运算符对操作数执行加法运算
- `-`运算符从第一个数中减去第二个数
- `*`运算符将操作数相乘
- `/`运算符用第一个数除以第二个数，如果两个数都是整数，则结果为商的整数部分，如`17/3=5`
- `%`运算符生成第一个数除以第二个数后的余数。两个操作数必须都是整数，将该运算符用于浮点数会导致编译错误。如果其中一个是负数，则结果的符号应该满足规则：`(a/b)*b+a%b=a`

#### 2.4.1 运算优先级和结合性

一般来说算术运算符的优先级与通常的代数系统运算级是相同的：先乘除再加减，也可以使用括号定义优先级。当操作数两侧的算术运算符的优先级相同时，C++将根据这些算术运算符的结合性进行运算，例如乘除的结合性是从左往右的，于是`10/2*4=20`而不是`10/2*4=1`。

#### 2.4.2 类型转换

C++允许将一种类型的值赋给另一种类型的变量，当这样做时，值将被转化为接收变量的类型。将一个值赋给取值范围更大的类型通常不会发生问题，但是将更大的类型转化为较小取值范围的类型时会出现问题：

|转换|潜在的问题|
|:---:|:---:|
|将较大的浮点类型转换为较小的浮点类型，如将`double`转换为`float`|精确度（有效位数将降低，值可能超出目标类型的取值范围，在这种情况下结果将是不确定的|
|将浮点类型转换为整型|小数部分丢失，原来的值也有可能超出目标类型的取值范围而导致结果的不确定|
|将较大的整型转换为较小的整型，如将`long`转换为`short`|原来的值可能超出目标类型的取值范围，通常只复制右边的字节|

初始化时将另一种类型的值赋给变量时也发生同样过程的类型转换。

C++将使用大括号的初始化称为**列表初始化**，其对类型转换的要求更为严格，列表初始化不允许缩窄（当变量的类型无法表示赋给它的值时），而类型范围的扩大是被允许的：

``` cpp
const int int_1 = 66;
int int_2 = 66;
char char_1 {31325};    //not allowed, narrowing
char char_2 {66};       //allowed because char can hold 66
char char_3 {int_1};    //allowed because int_1 is a constant
char char_4 {int_2};    //not allowed, int_2 is not a constant
int_2 = 31325;
char char_5 = int_2;    //allowed, this is not list-initialization
```

在计算表达式时，C++将`bool`、`char`、`unsigned char`、`signed char`和`short`值转换为`int`。对于`bool`类型，`true`类型转换为`1`，`false`类型转换为`0`。所有这些变换称为**整型提升**。

为了保证在整型提升过程中不会出现数据的损失，C++确定了以下规则：如果`short`比`int`短，则`unsigned short`类型将被转换为`int`，如果两种类型的长度相同，则`unsigned short`类型将被转换为`unsigned int`；同样，`wchar_t`将被提升为`int`、`unsigned int`、`long`或`unsigned long`中第一个宽度足够存储`wchar_t`的整型。

将不同类型的变量进行算术运算时也会发生一些类型转换：当运算涉及两种类型时，较小的类型将被转换为较大的类型，例如`int`与`float`类型相加时`int`转换为`float`。

C++允许通过强制类型转换机制显示地进行类型转换：例如对存储在变量`thu_id`中的`int`值转换为`long`类型时，可以采取以下表达式中的一种：

``` cpp
(long) thu_id;  //(typename) value
long (thu_id);  //typename (value)
```

强制类型转换不会修改变量本身，而是创建一个新的、指定类型的值。第二种格式是C++的新格式，其想法是将强制转换类型视为C++中的一种函数调用，例如`cout << int('Q')`这样的表达式就用到了类似函数行为的强制转换类型方法。

C++11新增了一种用于编译器根据初始值的类型推断变量的类型，它重新定义`auto`的含义如果使用关键字`auto`而不指定变量的类型，编译器将把变量的类型设置为与初始值相同。

<br>

<br>

<br>

## 3 复合类型

<br>

### 3.1 数组

<br>

数组是一种数据类型，能够存储多个同类型的值，创建数组可以使用声明语句，这要指出数组的三个确定条件：
- 存储在每个元素中的值的类型
- 数组名
- 数组中元素的个数

``` cpp
short months[12];
```

通用格式如下：

``` plaintext
typename arrayName[arraySize] = {element_1, element_2, etc.};
```

注意`arraySize`参数指定数组的元素个数，其必须是一个整型常数或者有确定值且值为整型的表达式，即该参数不能用非整型常量、变量来表示。

数组的重要功能是可以单独访问数组内的元素，方法是使用从`0`开始的下标或索引来对元素进行编号，C++使用带索引的方括号表示法来指定数组元素，例如`months[0]`是`months`数组的第一个元素。编译器不会检查使用的下标是否有效，如果将一个值赋值给数组内不存在的元素时，编译器并不会指出错误，但这很有可能引发一些问题。

C++允许在声明语句中初始化数组元素：

``` cpp
double line_event_1[6] = {120.0, 240.0, 330.0, 400.0, 255.0, 30.0};
//     line_event_1[6] = {head_x_point, end_x_point, head_y_point, end_y_point, alpha, rotation}
```

只有在定义数组时才能使用初始化，此后便不能使用了，也**不能将一个数组赋值给另一个数组**，但可以使用下标分别给数组中的元素赋值。初始化数组时，提供的值可以少于数组的元素数目，这种初始化语句只对数组前几个元素进行赋值。如果初始化的方括号中没有数字，则C++将对初始化花括号内中元素的个数决定数组的大小。C++11中的列表初始化新增了三个功能：
- 初始化时可以省略等号`=`
- 可不在花括号内包含任何元素，这样设置将使数组中所有元素初始化为零
- 列表初始化禁止缩窄转换

<br>

### 3.2 字符串

<br>

C++处理字符串可以是C-风格字符串，也可以是基于`string`类库的方法。C-风格字符串的特征是以空字符结尾，空字符被写作`\0`，例如下面一个`char`数组是C-风格字符串：

``` cpp
char love[12] = {'i', 'l', 'o', 'v', 'e', 's', 'a', 'g', 'i', 'r', 'i', '\0'};
```

上述字符串的表示方法非常麻烦，而且如果在结尾没有加上空字符时，使用`cout`对象给该字符串输出时可能有意想不到的结果。可以使用字符串字面量简化字符串的初始化：

``` cpp
char love[12] = "ilovesagiri";
```

注意字符串的数组元素个数要包含末尾的空字符（C++在处理字符串时默认在末尾添加一个空字符），当然也可以在方括号内不填写数字以让C++自动统计字符个数。注意字符串字面量使用的双引号`"`和字符字面量使用的单引号`'`不能混淆。

C++允许拼接字符串字面值，可以将两个用引号括起来的字符串合并为一个，任何两个由空白分隔的字符串常量都将自动拼接成一个，但是要注意第一个字符串的末尾的`\0`字符会被第二个字符串的第一个字符代替：

``` cpp
cout << "I love" " sagiri!";
cout << "I love"
" sagiri!";
```

`sizeof`运算可以计算数组元素个数，`strlen()`函数可以计算存储在字符串中的可见的字符数（即不包括末尾`\0`字符）。

``` cpp
#include <iostream>
#include <cstring>

int main() {
    using namespace std;
    char wife_name[20] = "Izumi Sagiri";  
    cout << sizeof(wife_name) << endl;
    cout << strlen(wife_name) << endl;
    return 0;
}
```

智能对象`cin`也有不好的地方，当它将通过键盘输入的含有空字符的字符串存入数组时，它会找到字符串中的第一个空字符并将空字符前的字符串存入数组，后面的字符串将存给下一个数组。

#### 3.2.1 读取一行字符串输入

`getline()`函数读取整行，它使用用户通过回车符输入的换行符确定行的结尾：

``` cpp
cin.getline(arrayName, arraySize);
```

该方法最多能读取`arraysize - 1`个字符，最后一个字符被保留作为空字符，且该函数不将输入的字符串末尾的换行符转换为空白符；`get()`函数的行为与`getline()`是类似的，但是它不读取末尾的换行符并将其留在输入队列中，因此第二次调用`get()`时C++可能会认为输入的第一个字符为换行符并且发现没有可读取的内容。使用不带任何参数的`get()`可以读取下一个字符，于是可以为第二个输入字符串的有参数的`get()`作好输入的准备：

``` cpp
cin.get(wife_name, arraySize);
cin.get();
cin.get(husband_name, arraysize);

/*
or can write as:
cin.get(wife_name, arraySize).get();
cin.get(husband_name, arraySize);
*/
```

一般来说应该使用`get()`而不是`getline()`，老式的C++没有`getline()`函数，并且`get()`使得检查错误更加简单。

#### 3.2.2 混合输入数字和字符串

对于有混合输入数字和字符串的情况，使用`getline()`可能会导致出错：

``` cpp
#include <iostream>

int main() {
    using namespace std;
    int wife_age;
    char wife_name[20];
    cin >> wife_age;
    // cin.get();
    // (cin >> year).get();
    cout << "What's her name?\n";
    cin.getline(wife_name, 20);
    cout << "Your wife is:" << wife_name << endl;
}
```

输入数字后的换行符将被`cin.getline(wife_name, 20)`读取到并被C++认为是一个空行而将空字符串赋值给`wife_name`。解决的方法是在此语句前加入`cin.get()`。

#### 3.2.3 `EOF`文件尾条件

大部分操作系统支持文件的重定向，假设Windows系统中有一个名为`latexTOmd.exe`的可执行文件，同目录下有一个名为`NormalPhysics.txt`的文本文件，可以使用命令行指令：

``` plaintext
latexTOmd.exe < NormalPhysics.txt
```

程序将从文本文件获取输入，`<`符号是Unix和Windows命令提示符模式的重定向运算符。文件尾条件（End of File，`EOF`，其值为-1，这不会和任何字符混淆）可以使用键盘进行模拟，例如在Windows11系统下`Ctrl+Z+Enter`即可模拟`EOF`（这在不同系统下通常是不同的）。检测到`EOF`时，`cin`将两位（`eofbit`与`failbit`）都设置为1。可以通过成员函数`eof()`查看`eofbit`的值，检测到`EOF`时该函数将返回`bool`类型的`true`，否则返回`false`，同样成员函数`fail()`的功能是一样的。

``` cpp
#include <iostream>

int main() {
    char ch;
    int count;
    std::cin.get(ch);
    while (std::cin.eof() == false) {
        std::cout << ch;
        ++count;
        std::cin.get(ch);
    }
    return 0;
}
```

上述程序中的`while (std::cin.eof() == false) {}`是常用的字符输入做法，该语句还可以被简化：方法`cin.get(char)`返回的是一个`cin`对象，当`cin`对象出现在需要`bool`值的地方，一个`istream`类中的函数将被自动调用，它可以将`cin`对象转换为一个`bool`值，如果最后一次读取成功了，将转换为`true`，否则为`false`。因此该语句可以被改写为：

``` cpp
while (std::cin.get(ch)) {}
```

这是更通用的读取字符的方式。

#### 3.2.4 文本文件的输入/输出

进行文本文件的输入与输出，必须包含头文件`fstream`。通过`ifstream`类创建进行文本输入的对象，并用`open()`方法打开指定文件名的文件；通过`ofstream`类创建进行文本输出的对象，也可用`open()`方法打开或创建指定文件名的文件，结束输入或输出后用`close()`方法关闭。

文件内的输出与输入的方法和`iostream`类对象是类似的，都可以用`get()`、`getline()`方法或者输出、输入的运算符`<<`和`>>`。还可以用方法`is_open()`或`good()`进行文件创建检视。

``` cpp
char filename[50];
char file_txt[70];
char TXT[] = ".md.txt";
std::cout << "Please enter the name of your LaTeX file: ";
std::cin >> filename;
strcpy(file_txt, filename);
strcat(file_txt, TXT);

std::ifstream latex;
std::ofstream markdown(file_txt, std::ios::out | std::ios::binary);
latex.open(filename);
markdown << "\xEF\xBB\xBF";
if (!latex.is_open()) {
    std::cout << "Can't load the file " << filename;
    std::cout << "Program exit.\n";
    exit(EXIT_FAILURE);
}
if (!markdown.is_open()) {
    std::cout << "Can't creat the file " << file_txt << "\n";
    std::cout << "Program exit.\n";
    exit(EXIT_FAILURE);
}
```

<br>

### 3.3 `string`类

<br>

要使用`string`类必须在程序中包括头文件：`#include <string>`，且`string`类在名称空间`std`中。`string`类定义隐藏了字符串的数组性质，能够使用如处理普通变量般处理字符串。

``` cpp
#include <iostream>
#include <string>

int main() {
    using namespace std;
    string wife_name;
    string husband_name = "AshGrey";
}
```

类设计能够使程序自动处理字符串的大小，而不用指定字符串数组的大小。

#### 3.3.1 `string`类的赋值、拼接和附加

- 可以将一个`string`对象赋给另一个`string`对象：

    ``` cpp
    string wife_name = "sagiri";
    string husband_name = "AshGrey";
    string identity;
    identity = wife_name;
    ```

- 可以使用运算符`+`将两个`string`对象合并，还可以使用运算符`+=`将字符串附加到`string`对象的末尾。

    ``` cpp
    string wife_name = "sagiri";
    string husband_name = "AshGrey";
    string love;
    husband_name += " love ";
    love = husband_name + wife_name;
    ```

#### 3.3.2 `string`类的其他操作

头文件`<cstring>`提供了一些对`string`对象操作的函数：
- `strcpy()`函数接受两个参数，它将字符串复制到字符数组中；
- `strcat()`函数接受两个参数，它将字符串附加到字符数组末尾；
- `strncpy()`函数接受指出目标数组最大允许长度的第三个参数，因此不会因超出字符数组的长度而导致相邻内存的覆盖与数据的损坏；
- `strncat()`函数与`strncpy()`函数的目的是一样的；
- `strlen()`函数是一个常规的函数，它接受一个C-风格字符串作为参数，并返回该字符串包含的字符数；
- `cin`与`cout`类方法可以用于处理`string`对象。

<br>

### 3.4 结构体

<br>

结构是一种比数组灵活的数据格式，同一个结构可以存储多种类型的数据。结构是用户定义的类型，结构声明定义了这种类型的数据属性，首先定义结构描述，描述并标记能够存储在结构中的各种数据类型，然后按描述创建结构变量。

``` plaintext
struct structName {
    type_1 name_1 value_1;
    type_2 name_2 value_2;
    ...
};
```

`struct`关键字表明创建一个结构，定义结构之后便可以创建这种类型的变量（C++允许在声明结构变量时省略关键字`struct`：

``` cpp
#include <iostream>
#include <string>
struct wife {
    string name;
    string appearWork;
    int age;
};

int main() {
    using namespace std;
    wife wife_1 {
        "Izumi Sagiri",
        "Eromanga Sensei",
        12
    };
    wife wife_2 {
        "Charlotte Sorel",
        "Isekai Pharmacy",
        9
        // Hentai!
    };
}
```

**可以使用成员运算符点号`.`来访问各个成员**，例如`wife_1.name`。创建结构复合类型的变量的同时可以初始化该变量，只要按照顺序初始化这些成员变量即可。成员变量之间用`,`隔开。

结构的声明可以紧贴放在`main()`函数的开始括号的后面，这是一种**局部声明**，该结构只能在该函数体内使用（对于其他定义的函数也是同理的）；也可以放在`main()`函数的前面，这是一种**全局声明**，这样定义的结构能在所有函数体内使用。变量也可以选择使用**局部定义**和**全局定义**，定义在函数外部的结构复合类型变量将被所有函数体共用。

C++不建议使用结构复合类型变量的全局定义，推荐使用结构声明的全局声明。

C++支持将列表初始化用于结构，且等号是可选的。初始化还可以在定义结构时进行，此时可以选择不提供结构的名称，而是直接创建多个符合该结构的变量。

``` cpp
wife wife_1 = {"Izumi Sagiri", "Eromanga Sensei", 12};

struct wife {
    string name;
    string appearWork;
    int age;
} wife_1, wife 2; 
// struct 'wife' can be used repeatedly.

struct {
    string name;
    string appearWork;
    int age;
} wife_1, wife_2;
// strcuct doesn't have a name.
```

C++可以将结构作为参数传递给函数，也可以让函数返回一个结构。还可以使用赋值运算符将结构赋值给另一个同类型的结构，这种赋值被称为**成员赋值**。

可以创建元素为结构复合类型的数组，该数组内的每一个元素都是结构，后面对这些元素进行初始化时不需要再指定结构名称：

``` cpp
#include <iostream>
#include <string>

struct wife {
    std::string name;
    std::string appearwork;
    int age;
};

int main() {
    wife bishojo[100];
    bishojo[0] = {
        "Izumi Sagiri",
        "Eromanga Sensei",
        12
    };
    bishojo[2] = {
        "Charlotte Sorel",
        "Isekai Pharmacy",
        9

    };
}
```

结构还可以与**位字段**一起使用，C++允许指定占用特定位数的结构成员，这使得创建与某个硬件设备上的寄存器对应的数据结构比较方便。字段的类型应当是整型或者枚举，接下来是一个`:`和一个数字，该数字指定了使用的位数，**可以使用没有名称的字段来提供间距**。结构中的每一个成员被称为**位字段**，位字段的技术通常用于低级编程中：

``` cpp
struct register_light {
    unsigned int SN : 4;
    unsigned int : 4;
    bool light : 1;
};
```

<br>

### 3.5 共用体

<br>

**共用体**这种数据格式可以存储不同的数据类型，但它只能同时存储一种数据类型。共用体的句法与结构类似，但是含义不同，对于下面这个程序，结构`wife_1`的变量`id_val`有时候是`long`类型，有时候又是`char`类型的：

``` cpp
#include <iostream>
#include <string>

struct wife {
    std::string name;
    std::string appearwork;
    int age;
    union id {
        long id_num;
        char id_char[20];
    } id_val;
};

int main() {
    wife wife_1;
    std::cin >> wife_1.age;
    if (wife_1.age <= 12) {
        std::cin >> wife_1.id_val.id_char;
        std::cout << wife_1.age << ":" << wife_1.id_val.id_char << std::endl;
    }
    else {
        wife_1.id_val.id_num = 2022012050;
        std::cout << wife_1.age << ":" << wife_1.id_val.id_num << std::endl;
    }
}
```

**匿名共用体**没有名称，其成员将成为位于相同地址处的变量，如果在结构中使用匿名共用体，则匿名共用体中的成员将被视为结构中的成员，不需要再通过中间标识符`id_val`进行访问。

``` cpp
#include <iostream>
#include <string>

struct wife {
    std::string name;
    std::string appearwork;
    int age;
    union {
        long id_num;
        char id_char[20];
    };
};

int main() {
    wife wife_1;
    std::cin >> wife_1.age;
    if (wife_1.age <= 12) {
        std::cin >> wife_1.id_char;
        std::cout << wife_1.age << ":" << wife_1.id_char << std::endl;
    }
    else {
        wife_1.id_num = 2022012050;
        std::cout << wife_1.age << ":" << wife_1.id_num << std::endl;
    }
}
```

在嵌入式开发中需要保证内存开销足够程序正常允许，共用体这种一次只能存储一种类型的特性导致它特别适合嵌入式开发。

<br>

### 3.6 枚举

<br>

C++的`enum`工具提供了创建符号常量的方式，这种方法可以代替`const`关键字：

``` cpp
enum natural_number {
    zero, one, two, three, four, five
}
```

该工具使`natural_number`成为新类型的名称，并将从零开始的整数依次赋值给枚举体内的变量。在定义枚举之后，也可以显式地指定整数值覆盖默认值。

枚举的特性如下：
- 只能将定义枚举时使用的枚举量（不能使用显式的整型字面值）赋值给这种枚举的变量；
    
    ``` cpp
    enum natural_number {
        zero, one, two, three, four, five
    };

    natural_number id;
    id = five;
    ```

    - 枚举只定义了赋值运算符，没有定义其他算术运算符，`id = one + two`或`id++`这样的表达式会抛出错误；
- 枚举量是整型，可以被提升为`int`类型，但`int`类型不能自动转换为枚举类型；
- 可以使用赋值运算符来显式地设置枚举量的值，指定的值必须是整数，也可以只显式地定义其中一些枚举量的值，后面没有初始化的枚举量的值默认比前面的枚举量大1，还可以创建多个值相同的枚举量：

    ``` cpp
    enum bits {zero, one = 0, two = 2, three}
    ```

    - 枚举量的强制类型转换有一定的取值范围：首先找出枚举量的最大值，找到大于这个最大值最小的2的次幂，将该次幂减一就得到取值范围的上限。

### 3.7 指针和自由存储空间

**指针**是一个变量，其存储的是值的地址，而不是值本身，对变量进行`&`运算符即可获得它的地址。显示地址时一般使用十六进制，如`0x5ffe8c`。

``` cpp
int number = 1;
number = expotional(number);
std::cout << "The address of 'number' is" << &number;
```

`*`运算符被称为**间接值**或**解除引用运算符**，将其应用于指针可以得到该地址处存储的值（C++编译器通过上下文确定所指的是乘法还是解除引用）：

``` cpp
#include <iostream>

int main() {
    int updates = 6;
    int* p_updates;
    p_updates = &updates;

    std::cout << "The address of 'updats' is " << p_updates << std::endl;
    std::cout << * p_updates << " = " << updates;
}
```

#### 3.7.1 声明和初始化指针

**指针声明必须指定指针指向的数据的类型**。例如语句`int* p_updates`表示变量`p_updates`是一个指向`int`类型变量的指针变量。但是要注意语句`int* p_1, p_2`声明的是指针变量`p_1`和一个`int`类型的变量`p_2`。对于不同的变量，指向这些变量的指针的初始化语句也不同，和数组一样，指针都是基于其他类型的。

可以在声明语句中初始化指针，在这种情况下被初始化的是指针而不是指针指向的值（一个重要的注意点是`pt`是指针，而`* pt`并不是一个指针）：

``` cpp
int* pt = &wife_name
```

错误地使用指针是危险的，例如对于下列程序：

``` cpp
int* pt;
* pt = 2578
```

C++将语句`* pt = 2578`解释为`pt`指针指向的地址处应当存储数值`2578`，但是`pt`指针并没有被初始化（或者此前初始化的位置并不是我们想要的），C++将把数值`2578`存储到我们并不想要它出现的内存中。

指针不是整型，但是计算机通常把地址当作整数处理。从它们可以执行的操作上看两者还是有区别的，因此不能简单地将整数赋给指针。在C99标准发布之前语句`pt = 0xB8000000;`是被允许的，但现在的C++对此种赋值语句的要求更加严格了，需要使用这样的语句：`pt = (int*) 0x8000000`。

#### 3.7.2 使用`new`分配内存

在C语言中可以使用库函数`malloc()`函数来分配内存，C++中也可以这么做，但是C++有更好的工具：`new`运算符。`new`运算符为指定的数据类型找到一个长度正确的内存块，并返回该内存块的地址，可以将该地址赋值给一个指针：

``` cpp
int* pt = new int;
```

在这里指针指向的地址没有被给予名称，所以使用存储在该地址的数值必须使用指针的解除引用运算符。需要指出的是：`new`分配的内存块通常与常规变量声明分配的内存块不同，常规变量声明通常存储在**栈**的内存区域中，而`new`运算符分配的内存通常在**堆**或称**自由存储区**的内存区域。

``` cpp
#include <iostream>

int main() {
    int* pt = new int;
    * pt = 12;
    std::cout << pt;
}
```

#### 3.7.3 使用`delete`释放内存

`delete`运算符使得在使用完内存后能够将内存归还给**内存池**，归还或释放的内存可以供给程序其他部分使用。使用`delete`运算符时，后面应当加上指向内存块的指针，这将释放指针指向的内存，但不会删除指针本身。注意一定要配对地使用`new`运算符和`delete`运算符，否则将发生**内存泄漏**，被分配的内存因为没有释放而无法再使用，如果内存泄漏严重，程序将由于不断寻找更多的内存而终止。

**不要释放已经释放的内存**，这样做的结果会导致程序运行结果不确定。**不能使用`delete`释放声明变量所获得的内存**。可以对空指针（计算机由于没有足够的内存而无法满足`new`的请求，在较老的实现中，此时的`new`将返回`0`，这样的指针没有指向有效的地址，被称为**空指针**）使用`delete`。

``` cpp
int* point_1 new int;
delete point_1;     //alowed
delete point_1;     //not allowed
int* point_2 = &wife_age;
delete point_2;     //not allowed
```

#### 3.7.4 使用`new`创建动态数组

在编译时给数组分配内存被称为**静态联编**，意味着数组是在**编译时**加入到程序中的。但使用`new`运算符，可以在运行阶段需要数组的时候创建它，不需要的时候不创建，还可以在程序运行时选择数组的长度，这被称为**动态联编**，并意味着数组是在程序**运行时**创建的，这种数组被称为**动态数组**。

创建动态数组需要提供数组类型以及数组元素个数，并使用`new`运算符配套指针的定义。当程序使用完`new`分配的内存块时应该使用`delete`释放它们，注意对于使用`new`创建的动态数组应当使用带方括号的`delete`释放内存：

``` cpp
int* list = new int [10];
delete [] list;
```

`list`指针指向数组的第一个元素。程序可以跟踪了分配的内存量，但这种信息并不是公用的，如不能使用`sizeof`运算符确定动态分配的数组包含的字节数。

可以将指针名作为数组名对数组内的元素进行调用：`list[2] = 12;`，这种语句能实现的原因是C/C++内部就是使用指针处理数组的。使用`new`创建的动态数组与常规数组的区别在于，可以对动态数组的指针变量进行操作：

``` cpp
#include <iostream>
#include <cstdlib>

int main() {
    double* number = new double[3];
    number[0] = 0.1;
    number[1] = 0.2;
    number[2] = 0.3;
    number[3] = 0.4;
    std::cout << number[2] << std::endl;
    number = number + 1;
    std::cout << number[2] << std::endl;
    number = number - 2;
    std::cout << number[2] << std::endl;
    number = number + 1;
    delete [] number;
    return 0;
}
```

#### 3.7.5 指针算术与数组

C++将数组名解释为地址：

``` cpp
int number[3] = {1,2,3};
std::cout << number;
```

该程序将输出数组第一个元素的地址（数组在内部处理被视作指针，指针初始化为第一个元素的地址）。而指针算术指的是指针指向地址的变化（内存中地址存储的值不会发生变化），将指针变量加1后，其增加的值等于指向的类型占用的字节数。对于数组表达式`number[3]`，C++将其视作`* (number + 3)`。在使用数组元素的表示（或者指针名表示）时，C++都执行转换：

``` plaintext
arrayname[i] becomes * (arrayname + i)
pointername[i] becomes * (pointername + i)
```

对数组使用`sizeof()`运算符得到的是数组的长度，对指针应用`sizeof()`运算符得到的是指针的长度，例如程序

``` cpp
#include <iostream>
#include <cstdlib>

int main() {
    int a_number[3] = {1,2,3};
    int* b_number = new int[3];
    b_number[0] = 1;
    b_number[1] = 2;
    b_number[2] = 3;
    std::cout << sizeof(a_number) << std::endl;
    std::cout << sizeof(b_number) << std::endl;
    delete b_number;
    return 0;   
}
```

该程序在`x64`位系统上的输出是`12`和`8`，前者是指数组`a_number`内所有元素所占字节位数（一个`int`类型的元素占内存4字节），后者是指针`b_number`（它的值是一个地址，在`x64`位系统中的位数为8字节）。

C++中，数组名被解释为其第一个元素的地址，而当对数组取地址时，其被解释为整个数组的地址。例如对于上述程序，`b_number + 1`将对地址值加4个字节，`&b_number + 1`将对地址值加12个字节。

#### 3.7.6 指针与字符串

注意如果给`cout`提供一个指针，它将打印地址，但是如果指针的类型为`char*`，则`cout`将显示指向的字符串，如果要显示指针所指向的地址，则必须将这种指针转换为另一种类型：例如`int*`。

``` cpp
char animal[20] = "Bear";
char* p_animal;
p_animal = animal;
cout << p_animal << "at" << (int* ) p_animal << endl;
```

要获得字符串的副本，首先需要分配内存来存储该字符串，这可以通过声明另一个数组或者使用`new`来完成，后一种方法使得能够根据字符串的长度来指定所需的空间：`p_animal = new char[strlen(animal) + 1]`。这样做能节省空间。接下来需要将`animal`数组中的字符串复制到新分配的空间中，注意直接将`animal`赋给`p_animal`是不行的，这样只能修改`p_animal`所指的地址，从而失去程序访问新分配内存的唯一途径。这时需要使用库函数`strcpy()`，该函数接受两个参数，第一个参数是目标地址，第二个是要复制的字符串的地址。

通常使用`strcpy()`函数或者`strncpy()`函数将字符串赋值给数组而不是赋值运算符`=`，为避免赋值给数组的字符串超出数组范围，可以使用`strncpy()`函数，该函数还接受第三个参数，可以指定要复制的最大字符数。要注意的是，如果该函数在到达字符串结尾之前，目标内存已经被用完，则它不会添加空字符，因此需要写成：

``` cpp
char* animal = new char[19];
strncpy(animal, "I like catgirl just like I love Izumi Sagiri.", 19);
animal[19] = '\0';
cout << animal << endl;
```

#### 3.7.7 使用`new`创建动态结构

创建动态结构时，需要同时使用结构类型和`new`，例如下面就是创建一个没有命名的`wife`结构，并将该结构的地址赋值给`p1_wife`：

``` cpp
wife* p1_wife = new wife;
```

这种创建的结构不能使用句点成员运算符(`.`)来访问结构内的成员，因为这种结构是没有名称的，只是知道它的地址。**C++为访问只知道地址的动态结构提供了新的箭头成员运算符(`->`)**。还有一种方法是**先对指向动态结构的指针执行解除引用运算符再使用句点成员运算符**。

``` cpp
#include <iostream>
#include <cstring>

struct wife {
    int age;
    std::string name;
    std::string appearwork;
};

int main() {
    wife* p1_wife = new wife;
    p1_wife -> age = 12;
    (*p1_wife).name = "Izumi Sagiri";
}
```

#### 3.7.8 自动存储、静态存储和动态存储

- 自动存储
  
    在函数内部定义的常规变量使用自动存储空间，被称为**自动变量**，它们在所属的函数被调用时自动产生，在函数结束时消亡。自动变量就是一个局部变量，其作用域就是包含它的代码块。自动变量通常存储在栈中，这些变量将依次加入到栈中，而在离开代码块时，将按相反的顺序释放这些变量，这被称为**后进先出**(LIFO)。

- 静态存储
    
    静态存储是整个程序执行期间都存在的存储方式，使变量成为静态的方式有两种：一种是在函数外部定义它，另一种是在声明变量时使用关键字`static`。

    ``` cpp
    static double key = 2673.32;
    ```

- 动态存储
    
    `new`和`delete`运算符提供了比自动变量和静态变量更加灵活的方法：它们管理了一个内存池，在C++中被称为自由存储空间或者堆。在堆中的数据不完全受程序或函数的生存时间控制，而是由程序员控制。在栈中，自动添加和删除机制使得变量占用的内存总是连续的，但是在堆中`new`和`delete`的相互影响可能导致占用的堆的内存不连续。

<br>

### 3.8 数组替代品

<br>

模板类`vector`类似于`string`类，也是一种动态数组，实际上模板类`vector`用`new`和`delete`管理内存。要使用`vector`对象，必须包含头文件`vector`，且包含在名称空间`std`中。

``` cpp
std::vector<int> age;
std::vector<double> born_time;  
```

`vector`类要比数组更加容易处理，它可以在在插入或添加值时自动调整长度。声明

``` plaintext
vector <typeName> vectorName(i_elem);
```

创建了元素个数为`i_elem`的动态数组，其中参数可以是整型常量也可以是整型变量。`vector`类的功能比数组强大，但是效率更低。

C++11新增了模板类`array`，要使用该对象需要包好头文件`array`，它也位于名称空间`std`下，与数组一样，`array`对象的长度是固定的，并且也使用栈而不是堆分配内存，其效率与数组相同，但是更加安全。与数组很不一样的是，`array`对象可以直接赋值给另一个`array`对象。其创建方式为：

``` plaintext
array <typeName, n_elem> arrayName;
```

注意一般数组、`array`对象、`vector`对象都可以使用带方括号的索引使用其中的元素。一般的数组在出现类似`list[-2]`这样的索引时，C++并不会报错，但这会对数组所在内存外进行操作并产生危险的行为，而`array`和`vector`对象的成员函数`at()`则可以在运行期间获取非法索引。以下是报错内容：

``` plaintext
terminate called after throwing an instance of 'std::out_of_range'
  what():  array::at: __n (which is 18446744073709551614) >= _Nm (which is 20)
```

<br>

<br>

<br>

## 4 循环语句和关系表达式

<br>

### 4.1 `for`循环

<br>

#### 4.1.1 `for`循环的组成部分

`for`循环的组成部分为：设置初始值-执行测试，判断循环是否应当继续进行-执行循环操作-更新用于测试的值。当测试的表达式为`true`时，循环体将被执行。`for`循环的结构如下：

``` plaintext
for (initialization; test-expression; update-expression) {
    body
}
```

循环只进行一次初始化，`test-expression`测试表达式决定循环体是否被执行，通常这个表达式是关系表达式，即对两个值进行比较；假如该表达式不是关系表达式，则C++将对`test-expression`强制转化为`bool`类型，因此值为0的表达式将被转化为`false`而导致循环退出，值为非零的表达式将被转化为`true`，循环将继续进行。

``` cpp
#include <iostream>
int main() {
    using namespace std;
    cout << "Enter the starting countdown value:";
    int start;
    cin >> start;
    int i;
    for (i = start; i >= 0; i--) {
        cout << "i = " << i << endl;
    }
    cout << "Done now that i = " << i << endl;
    return 0;
}
```

对循环的变量`i`的更新操作`i--`是对`i`进行减一的操作（回退操作），同理还有`i++`是对`i`进行加一的操作（后继操作）。上述的操作又可写作`--i`与`++i`。这样的操作符的前缀形式和后缀形式是有区别的，例如`i++`是指使用`i`的当前值计算表达式，然后再对`a`加一，而`++i`则是先对`i`加一再计算表达式。例如：

``` cpp
int a = 20, b = 20;
int a_double, b_double;
a_double = (a++) * 2;
b_double = (++b) * 2;
```

该程序执行完后`a_double`的值为`40`，`b_double`的值为`42`。

递增/递减运算符也可以用于指针实现指针的移动，但是在使用时要注意解除引用符以及递增/递减运算符之间的位置关系，具体来说，它们的优先级是：**前缀递增=前缀递减=解除引用<后缀递增=后缀递减**。例如：
- `*++ pt`中有前缀递增和解除引用运算符，两者优先级相同，结合性为`R-L`，所以该语句的意思是先将`++`应用于指针`pt`，然后将`*`应用于递增后的`pt`，即返回下一地址存储的值；
- `++* pt`的意思是先将`*`应用于指针`pt`，然后将`++`应用于解除引用后的值，即对指针`pt`所指向地址存储的值加上一；
- `(* pt) ++`的意思是先将`*`应用于指针`pt`（因为这里的括号的优先级最高），然后将`++`应用于解除引用后的值；
- `* pt ++`的意思是先将`++`应用于指针`pt`，这里后缀递增运算符的优先级更高的，但是在语句中使用的`pt`所指向的地址是不变化的，如原来是指向数组元素`arr[1]`，在这个语句中被解除引用后返回的值依旧是`arr[1]`，但语句结束后指针`pt`所指的地址递增，指向数组元素`arr[2]`。

`update-expression`一般是对循环变量进行增减的式子，但实际上它可以是任何有效的表达式或者其他控制表达式，例如更改步长：`i = i + by`，其中`by`是用户选择的步长值。**该表达式可以被简化为`i += by`**。每个操作符都有对应的组合赋值运算符，例如`+=`、`-=`、`*=`、`/=`和`%=`。

`for`循环中开头的语句可以用逗号运算符`,`隔开，可以用于对多个变量进行处理。这样的表达式称为**逗号表达式**，并且C++规定逗号表达式的值为逗号右侧表达式的值（该定义见下一段）。而且在所有运算符中，逗号运算符的优先级是最低的。

``` cpp
int i, j ;
char temp;
for (j = 0, i = word.size() - 1; j < i; --i, ++j) {
    temp = word(i);
    word[i] = word[j];
    word[j] = temp;
}
```

对于C++，任何值或任何有效的值和运算符的组合都是表达式，在C++中，每个表达式都有值。对于赋值表达式`x = 23`，其值为23，C++将赋值表达式的值定义为左侧成员的值，于是可以出现这样奇怪的语句：`m = (w = 3) + 4`，表达式`w = 3`的值为3，因此整个表达式的值为7。但是也可以写出具有明显意义的表达式：

``` cpp
x = y = z = 30;
```

这种方法可以快速地将若干个变量设置为相同的值，且赋值运算符是从右向左结合的。也可以将赋值语句或者其他表达式作为`cout`对象的输出结果：

``` cpp
#include <iostream>

int main() {
    using namespace std;
    int x;
    cout << (x = 100) << endl;
    cout << "Now the x is:" << x << endl;
    cout << "The expression 'x < 3' has the value:" << (x < 3) << endl;
    cout << "The expression 'x > 3' has the value:" << (x > 3) << endl;
    cout.setf(ios_base::boolalpha);
    cout << "The expression 'x < 3' has the value:" << (x < 3) << endl;
    cout << "The expression 'x > 3' has the value:" << (x > 3) << endl;
    return 0;
}
```

`ios_base::boolalpha`更改`cout`对象输出表达式的方式，可以改成`true`与`false`的输出形式。为判断表达式`x = 100`，C++必须进行赋值操作并修改了内存中的数据的值，可以说这是表达式的**副作用**。

C++可以在`for`循环的初始化部分声明变量，此时`for`循环的句法结构如下：

``` plaintext
for (for-init-statement condition; expression) {
    body
}
```

句法结构中只有一个分号的原因是这里的`for-init-statement condition`是一个语句，而语句拥有自己的分号，所以`for`循环体在形式上还是具有两个分号的。C++添加这样的新的句法结构的好处是：可以定义只在`for`循环体内部使用的变量，当程序离开循环后，这种变量就会从内存中释放。

``` cpp
int n, sum;
sum = 0;
for (int i = 1; i <= n; i++) {
    sum = sum + i;
}
```

`for`循环后的大括号围住的语句称为**复合语句**，复合语句中的变量的生命周期只在大括号内，例如：

``` cpp
int x = 2;
{
    std::cout << x << std::endl;
    int x = 12;
    std::cout << x << std::endl;
}
std::cout << x << std::endl;
```

该程序的复合语句中重新定义了新的变量`x`，离开了复合语句，新变量被释放，旧变量的值重新可以被使用。

#### 4.1.2 关系表达式

C++提供6种关系运算符，它们可用于对数字进行比较，也可以用于对单个字符（按照ASCII码或者计算机上使用的编码方式中字符的码位比较），还可以用于`string`类，但是不能用于`char`类数组。对于所有关系表达式，如果比较结果为真则返回`true`，如果比较结果为假则返回`false`。**关系运算符的优先级比算术优先级低**，于是关系表达式内的算术表达式不加括号也是可行的。

|操作符|含义|操作符|含义|操作符|含义|
|:---:|:---:|:---:|:---:|:---:|:---:|
|`<`|小于|`<=`|小于等于|`==`|等于|
|`>`|大于|`>=`|大于等于|`!=`|不等于|

由于C++将数组的名称、C-风格字符串视为地址，如果用关系表达式直接对C-风格字符串与目标的字符串进行比较，实际比较的是两个地址是否相等，而这是不可能正确的。对于C-风格字符串的关系表达式，应当使用C-风格字符串库中的`strmp()`函数来比较，该函数接受两个字符串地址为参数，该参数可以是**指针、字符串常量或字符串数组名**。
- 如果两个字符串相同，该函数返回`0`；
- 如果第一个字符串按系统编码排列顺序排在第二个字符串之前，该函数返回`<0`的值；
- 如果第一个字符串按系统编码排列顺序排在第二个字符串之后，该函数返回`>0`的值。

``` cpp
#include <iostream>
#include <cstring>

int main() {
    char wife[20] = "Izumi Sagiri";
    for (int i = 0; strcmp(wife, "Izumi Sagiri") == 0 && i <= 10; i++) {
        std::cout << wife[i] << std::endl;
    }
}
```

`string`类字符串可以直接使用关系运算符。

#### 4.1.3 基于范围的`for`循环

C++11新增了一种基于范围的`for`循环，这简化了一种常见的针对数组或容器类的每个元素执行相同操作的循环：

``` cpp
#include <iostream>

int main() {
    double pi[5] = {3, 3.1, 3.14, 3.141, 3.1415};
    for (double i : pi) {
        i = i * 2 + 1;
        std::cout << i << "\n";
    }
    for (int i = 0; i <= 4; i++) {
        std::cout << pi[i] << "\n";
    }
}
```

这段程序中数组的实际数值并不会发生变化，但如果`i`是一个引用型的变量（`double& a`），则可以直接改变数组内的元素。上述的代码是使用了数组内元素的副本，故数组内的元素实际不会发生变化。引用型的变量与指针变量不同的是引用型的变量的所有可以进行的操作与其引用的变量是一致的，不像指针变量需要使用解除引用符：

``` cpp
#include <iostream>

int main() {
    double pi[5] = {3, 3.1, 3.14, 3.141, 3.1415};
    for (double& i : pi) {
        i = i * 2 + 1;
        std::cout << i << "\n";
    }
    for (int i = 0; i <= 4; i++) {
        std::cout << pi[i] << "\n";
    }
}
```

<br>

### 4.2 `while`循环

<br>

`while`循环是没有初始化和更新部分的`for`循环，它只有测试条件和循环体。

``` plaintext
while (test-condition) {
    body
}
```

当`test-condition`语句为`true`时执行该循环体语句，直到该语句为`false`。

`while`循环的一个重要用处是**延时循环**，头文件`ctime`中定义了一个符号常量`CLOCKS_PER_SEC`，表示每秒钟包含的系统时间单位数；其中还有一个函数`clock()`，它用于返回程序开始执行后所用的系统时间，但是它返回的值的单位不一定是秒，且返回值在不同的实现中的类型并不一定是一样的，可能是`long`也可能是`unsigned long`或其他类型。但是头文件`ctime`将`clock_t`作为`clock()`返回类型的别名，编译器将它转换为适合系统的类型。

``` cpp
#include <iostream>
#include <ctime>

int main() {
    using namespace std;
    cout << "Enter the string you want to show:";
    char string[20];
    cin >> string;
    float secs = 1.0;
    clock_t delay = secs * CLOCKS_PER_SEC;
    clock_t start = clock();
    for (int i = 0; string[i] != '\0'; i++) {
        cout << string[i] << "\n";
        while (clock() - start < (i + 1) * delay);
    }
    return 0;
}
```

C++为类型建立别名的方式有两种，一种是使用**预处理器**：`#define BYTE char`。这样就完成了将`char`类型的变量称为`BYTE`类型的操作。另一种方法是关键字`typedef`：`typedef char BYTE;`。

<br>

### 4.3 `do-while`循环

<br>

`do-while`循环与前两种不同的是它是一个出口循环，这意味着这种循环将首先执行循环体再执行测试表达式，其句法为：

``` plaintext
do
    body
while (test-expression);
```

一般来说，入口循环体要比出口循环体要好一些，因为入口循环在循环开始之前检查了条件，防止出现一些不被允许的操作。例如读取越界的索引。

### 4.4 嵌套循环与二维数组

C++本身没有提供二维数组这一类型，但是用户可以自己编写一个元素是数组的数组，初始值赋值可以这样写（注意第一个方括号内的数字是子数组的个数，第二个方括号内的数字是子数组内元素的个数）：

``` cpp
int EXTRA_matrix[3][2] = { {2,3},{4,2},{3,4} };
```

可以使用嵌套循环访问二维数组内的元素：

``` cpp
#include <iostream>

int main() {
    int rows, columns;
    std::cout << "Enter the number of rows of the matrix:" ;
    std::cin >> rows, std::cout << "\n";
    std::cout << "Enter the number of columns of the matrix:" ;
    std::cin >> columns, std::cout << "\n";
    const int ROW = rows;
    const int COLUMN = columns;
    double matrix[COLUMN][ROW];

    std::cout << "Enter the matrix element:\n";
    for (int i = 1; i <= COLUMN; i++) {
        for (int j =1; j <= ROW; j++) {
            std::cout << "(" << i << "," << j << "):";
            std::cin >> matrix[i-1][j-1];
        }
    }

    std::cout << "The matrix is:\n";
    for (int i = 1; i <= COLUMN; i++) {
        for (int j =1; j <= ROW; j++) {
            std::cout << matrix[i-1][j-1] << "  ";
        }
        std::cout << "\t";
    }
    return 0;
}
```

## 5 分支语句和逻辑运算符

### 5.1 `if`语句

`if`语句类似不具有循环功能的`while`语句，句法为：

``` plaintext
if (test-condition)
    statement
```

如果语句`test-condition`值为`true`，则将执行分支语句下的代码，若为`false`则不执行。

一个语句的结果可能有多个，所以`if`语句也应当能够分辨不同情况，在不同情况下执行不同的操作，于是有了`else if`语句和`else`语句。`else if`语句后跟一个新的`test-condition`，`else`语句是在以上条件语句都不成立的时候才执行的：

``` plaintext
if (test-condition 1)
    statement 1
else if (test-condition 2)
    statement 2
else
    statement 3
```

### 5.2 逻辑表达式

#### 5.2.1 逻辑`OR`运算符：`||`

C++采用`||`将两个表达式组合在一起，如果原来表达式中的任意一个或全部为`true`，则得到的表达式的值为`true`，否则表达式的值为`false`。如

``` cpp
result > MAX || MAX == 0
```

`||`的优先级比关系运算符低，因此不需要在这些表达式中使用括号。C++规定，`||`运算符是一个顺序点，先修改运算符左侧的值，再对右侧式子进行判断。如果左侧的式子为`true`，则C++将不会判定右侧的表达式，因为只要有一个式子的值为`true`整个逻辑表达式的值就为`true`。

#### 5.2.2 逻辑`AND`运算符：`&&`

C++采用`||`将两个表达式组合在一起，如果原来表达式中全部为`true`，则得到的表达式的值为`true`，否则表达式的值为`false`。

``` cpp
result > MAX && MAX == 0
```

与`||`类似，`&&`运算符比关系运算符的优先级低，所以表达式也不需要加上括号。C++规定，`&&`运算符是一个顺序点，先修改运算符左侧的值，再对右侧式子进行判断。如果左侧的式子为`false`，则C++将不会判定右侧的表达式，因为只要有一个式子的值为`false`整个逻辑表达式的值就为`false`。

逻辑`AND`运算符`&&`的优先级比逻辑`OR`运算符`||`高。

#### 5.2.3 逻辑`NOT`运算符：`!`

逻辑运算符`!`将其后面表达式的真值取反，对于取值范围类型的表达式，使用`!`并没有什么作用，但是对于返回值为`bool`类型的函数，使用该逻辑运算符非常有作用：

``` cpp
#include <iostream>

bool is_prime(int n) {
    bool flag = true;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            flag = false;
            break;
        } 
    }
    return flag;
}

int main() {
    const int MAX = 1000;
    for (int j = 2; j <= MAX; j++) {
        if (!is_prime(j))
            std::cout << j << "\n";
    }
    return 0;
}
```

上面的程序用来寻找1000以内的合数。`!`运算符的优先级高于所有的关系运算符和算术运算符，所以要对表达式取反，则必须使用括号括起来。

以上所有的逻辑运算符都可以有另一个版本：`||`为`or`，`&&`为`and`，`!`为`not`。在C语言中，这三者不是保留字，但是在引用头文件`iso646.h`之后这三者也可以使用；在C++中这三者就是保留字，不需要引用头文件。

### 5.3 `?:`运算符

C++有一个常被用作代替`if else`语句的运算符，`?:`运算符被称作**条件运算符**，它是C++唯一需要三个操作数的运算符，其句法如下：

``` plaintext
expression1 ? expression2 : expression3
```

如果`expression1`的值为`true`，则整个表达式的值为`expression2`的值，否则整个表达式的值为`expression3`的值，例如找两个变量之间的较大者可以使用该运算符：

``` cpp
max = (a > b) ? a : b;
```

### 5.4 `switch`语句

`switch`语句的句法如下：

``` plaintext
switch (integer-expression) {
    case label1: statement (S)
    case label2: statement (s)
    ...
    default    : statement (s)
}
```

执行到`switch`语句，程序将跳到使用`integer-expression`的值标记的那一行，而`integer-expression`必须是一个结果为整数值的表达式，每个标签都必须是整数常量表达式，最常见的标签是`int`或`char`。注意C++不会在执行到下一个`case`处自动停止，要让程序执行完一组特定语句后停止，必须使用`break`语句。`switch`语句相当于简化的`if`语句。

``` cpp
#include <iostream>

int main() {
    int i;
    std::cin >> i;
    while (i != 1) {
        switch (i % 2) {
            case 1 : 
                i = i * 3 + 1;
                std::cout << ">" << i << "\n"; 
                break;
            case 0 : 
                i /= 2;
                std::cout << ">" << i << "\n";
                break;
        }
    }
}
```

`switch`语句常用于选择程序根据输入选择不同模式或选择不同功能。

`break`语句用于在`switch`语句或者任何循环体中，使程序执行`switch`语句或者循环之后的代码。`continue`语句用于循环中，让程序跳过循环体中余下未执行的代码并开始重新一轮的循环，注意条件更新语句并不会跳过。C++还有`goto`语句，用于跳转到具有`goto`关键字后的标签的代码处：

``` cpp
if (ch == '\n')
    goto OUTPUT;
...
OUTPUT: std::cout << result << "\n";
```

不应该经常使用`goto`语句，这会使程序的逻辑性与可读性降低。

## 6 函数

### 6.1 函数原型

函数原型语句通常放在`main()`函数之前，它们描述了函数到编译器的接口。函数原型是非常必要的，一些程序员可能会将函数原型语句与定义合并，但是这样做就必须使函数的定义放在`main()`函数之前，这对程序的可读性造成了比较大的影响（C++的编程风格是将`main()`函数放在最前面，它提供了程序的整体结构）。

### 6.2 函数参数与按值传递

C++通常按值传递参数，这意味着将数值参数传递给函数，后者将赋值给一个新的变量。例如对于原型为`std::string replaceKeyword(const std::string& input)`的函数，如果使用语句`tempLineString = replaceKeyword(tempLineString)`调用它，则`tempLineString`的值将赋值给函数体内部的变量`input`。用于接受传递值的参数称为**形参**或**参量（parameter）**，传递给函数的值称为**实参**或**参数（argument）**。

### 6.3 函数与数组

可以将数组作为参数传递给函数，但这里实际传递的其实是一个指针，所以函数原型或函数头可以写作两种形式：

``` cpp
double averageOfArray(double elements[], int n);
double averageOfArray(double* elements, int n);
```

实际上表面上传递的数组参数将数组的地址赋值给参量，于是如果函数内部有针对数组的修改语句，则传入的数组的值也会发生改变：

``` cpp
#include <iostream>

void backwardDiffer(double elements[], int n);

int main() {
    double list[4] = {1.2, 1.4, 1.6, 1.9};
    backwardDiffer(list, 4);
    for (int j = 0; j <= 3; j++)
        std::cout << list[j] << "\n";
    return 0;
}

void backwardDiffer(double elements[], int n) {
    for (int i = n - 1; i >= 1; i--)
        elements[i] = elements[i] - elements[i - 1];
}
```

主程序中的数组`list[]`的值经过向后差分函数`backwardDiffer()`修改后发生了变化。将数组类型和数量告诉数组处理函数，不能使用`backwardDiffer(int arr[arrSize])`这样的语句，而是需要使用两个参数进行传递。

对于传统的处理数组的C/C++函数，要处理一个数组的某个区间时，必须将数组的起始位置（一个指针变量）和数组元素数量两个参数传递给函数；或者也可以将数组的起始位置、数组的结束位置两个参数传递给函数，如：

``` cpp
double sumArray(const int* begin, const int* end) {
    const int* pt;
    double sum = 0;
    for (pt = begin; pt != end; pt++)
        sum += *pt;
    return sum;
}
```

注意以上传递的参数`const int* begin`指的是指针`begin`指向的是一个常量（对于该指针来说是这样的，即不能通过该指针修改指针指向位置的数据），而该指针指向的位置本身是可以变化的，但是变化后指向的数据也不能更改，所以总体效果是创建了一个**只能指向数据而不能修改数据的指针**。如果要创建**只能指向一个位置的指针**，则需要写作：

``` cpp
double* const pt = &doubleDistance;
```

对于二维数组，也可以有两种传递参数的书写方式：

``` cpp
double marix[3][4];
double matrixTranspose(double input[][4], int size);
double matrixTranspose(double (*input)[4], int size);
```

这些声明将创建一个由四个指向`double`类型的指针组成的数组，并且传递给函数的参量是一个指向这个数组的指针。同样的，访问传递进来的二维数组，同样需要使用嵌套循环处理数据。

将C-风格字符串作为参数的函数实际接受的数据还是**字符串的第一个字符的地址**，因为在C++中字符串的实质就是一个`char`类型的数组。

函数本身并不能实现返回一个数组，也就不能返回一个字符串，但是如果返回一个字符串的地址，效率会更高：

``` cpp
char* buildstr(char singleChar, int size) {
    char* result = new char[size + 1];
    result[size] = '\0';
    while (size-- > 0)
        result[size] = singleChar;
    return result;
}
```

### 6.4 函数与结构

#### 6.4.1 传递和返回结构

与数组不同的是，结构变量的行为更类似于一个基本的单值变量，结构变量的名称并不代表其第地址而单纯的就是名称。当结构的内存较小时，按值传递结构比较合理

``` cpp
struct judgeLine {
    double xPoint;
    double yPoint;
    double xPositiveAngle;
};

judgeLine lineRotate(judgeLine input, double newAngle) {
    input.xPositiveAngle = newAngle;
    return input;
}
```

#### 6.4.2 传递结构的地址

假设要传递结构的地址而不是整个结构，这样的做法可以节省时间和空间，不需要复制结构。传递结构的地址，需要对原来的处理结构的函数进行改造：
- 调用函数时，将结构的地址而不是结构本身传递给它
- 将形参声明为指向结构的指针
- 由于形参是指针而不是结构，因此需要使用间接成员运算符`->`而不是成员运算符`.`

``` cpp
struct judgeLine {
    double xPoint;
    double yPoint;
    double xPositiveAngle;
};

judgeLine* lineRotate(const judgeLine* input, double newAngle) {
    input -> xPositiveAngle = newAngle;
    return input;
}
```

### 6.5 递归

C++允许一个函数调用自身，该过程称为**递归**，但与C语言不同的是不允许`main()`函数调用自身。如果递归函数调用自身，则被调用的函数将会无限循环下去，除非代码中包含终止调用链的内容：例如将调用自身函数的语句以及返回值语句放在`if`语句中，当判断语句为`false`时，调用链将终止。

``` cpp
double binomial(int m, int n) {
    if (n == 1) {
        return m;
    }
    else if (m == n) {
        return 1;
    }
    else {
        double result = binomial(m - 1, n - 1) + binomial(m - 1, n);
        return result;
    }
}
```

当递归层数较多时，因为每一次调用递归函数都会产生新的变量，这些变量临时存储在内存中，层数较多的时候会占有大量内存，此时递归就不是好的解决问题的方式。

### 6.6 函数指针

程序在运行时，函数也临时存储在内存中，函数的地址是存储其机器语言代码的内存开始的地址。获取函数的地址很简单，函数名称与数组名称类似，都是代表其内存的开始地址，直接使用函数内存即可得到函数地址。

声明函数指针时必须指定指针指向的函数类型，声明应当指定函数的返回类型以及函数的参数列表：

``` cpp
void subDivision(char input[], int begin, int end, int level);
void (*function)(char*, int, int, int) = subDivision;
// or 'function = subDivision'
(*function)(output, min, max, i);
```

函数指针可以作为一个参数传入另一个函数，但这和函数调用另一个函数的效果没有区别；仅有的区别在于，这个接受参数的函数理论上可以调用无数种不同功能的函数，但它们的返回类型以及参数列表相同。甚至可以创建函数指针数组：

``` cpp
double estimate(void (*function)(char*, int, int, int), double input);
const double* (*function[3])(void (*pf)(char*, int, int, int), double input) = {f1, f2, f3};
```

### 6.7 内联函数与宏

C语言中有内联函数的早期实现，使用预处理器`#define`来提供宏，这并不是通过参数传递实现的，而是文本替换的技术；C++提供了内联函数以实现参数传递与宏的功能，它和常规函数不同的是内联函数与用内联代码替换函数调用，即整段程序在内联函数处不会调用存储在另一块的内存的函数，而是在原来的位置生成一段一样的函数。

宏的结构如下，需要换行时使用`\`来标明：

``` cpp
#define wxBEGIN_EVENT_TABLE(theClass, baseClass) \
    const wxEventTable theClass::sm_eventTable = \
        { &baseClass::sm_eventTable, &theClass::sm_eventTableEntries[0] }; \
    const wxEventTable *theClass::GetEventTable() const \
        { return &theClass::sm_eventTable; } \
    wxEventHashTable theClass::sm_eventHashTable(theClass::sm_eventTable); \
    wxEventHashTable &theClass::GetEventHashTable() const \
        { return theClass::sm_eventHashTable; } \
    const wxEventTableEntry theClass::sm_eventTableEntries[] = { \
```

### 6.8 引用变量

C/C++使用`&`表示变量的地址，而C++给`&`赋予了一个新的含义，将其用于声明引用。这里`&`并不是地址运算符而是类型标识符的一部分。引用使得函数能够直接使用原先的变量，而不是使用其副本。引用变量的行为类似于指针，但它们之间仍然具有区别：**必须在引用变量时进行初始化**，而指针可以先初始化再赋值。以下两行代码是等价的：

``` cpp
int& realName = wxFrameName;
int* const realName = &wxFrameName;
```

引用常用作函数参数，使得函数中的变量名成为调用程序中的变量的别名，这种传递参数的方法称为**引用传递**，按引用传递允许被调用的函数能够访问调用函数中的变量。对于使用`const`限定符的引用变量的函数，它在下列情况下会创建一个**临时匿名变量**，并让变量别名指向它，在调用函数结束后，这个临时匿名变量就会被释放：
- 实参的类型正确，但不是左值；
- 实参的类型不正确，但是可以转化为正确的类型。

**左值**指的是可被引用的数据对象（如变量、数组元素、结构成员、引用和解除引用的指针），非左值包括字面常量（用引号括起的字符串不属于字面常量，它们实际传递的值是所在的内存地址）和包含多项的表达式。在C++中，不管是常规变量还是`const`变量，它们都可以是左值，常规变量是可修改的左值，`const`变量是不可修改的左值。

``` cpp
#include <iostream>

double cube(const double& input);

int main() {
    double a = 3.0;
    std::cout << cube(a)   << "  " << a << "\n";
    std::cout << cube(3)   << "\n";
    std::cout << cube(3.0) << "\n";
}

double cube(const double& input) {
    return input * input * input;
}
```

以上程序中的`cube(3)`和`cube(3.0)`没有报错的原因就是对于使用`const`限定符的引用变量的函数，可以创建一个临时匿名变量用于存储接受到的的参数。

使用引用、指针、按值传递的指导原则；
- 对于使用传递的值而不作修改的函数：

  - 如果数据对象很小，如内置数据类型或者小型结构，则按值传递；
  - 如果数据对象是数组，则使用指针，这是唯一的选择，并将指针声明为指向`const`的指针；
  - 如果数据对象是较大的结构，则使用`const`指针或`const`引用；
  - 如果数据对象是类对象，则使用`const`引用。

- 对于修改调用函数中数据的函数：

    - 如果数据对象是内置数据类型，则使用指针；
    - 如果数据对象是数组，则只能使用指针；
    - 如果数据对象是结构，则可以使用引用或者指针；
    - 如果数据对象是类对象，则使用引用。

### 6.9 默认参数

默认参数是指当函数调用时省略了实参时自动使用的一个值，使用默认参数的方法是在函数原型中给参数赋值，函数定义语句和没有默认参数时一样。对于有参数列表的函数，必须从右往左添加默认值：

``` cpp
double InOutSin(double time, double begin = 0.0, double end = 255.0);
```

拥有默认参数的函数允许调用该函数是只提供部分参数，但是不能跳过某一个参数进行赋值：

``` cpp
value = InOutSin(10);           //OK
value = InOutSin(10, 15);       //OK
value = InOutSin(10, 15, 200);  //OK
value = InOutSin(10,  , 200);   //Invalid
```

### 6.10 函数重载

函数重载也被称为函数多态，指的是函数具有多种形式，且它们都是同名的。区分重载的函数的关键是函数的参数列表，也称为**函数特征标**。如果两个函数的参数数目和类型相同且参数的排列顺序也相同，则它们的函数特征标相同，变量名是无关紧要的。C++允许定义名称相同的函数，前提是**它们的函数特征标不同**，如：

``` cpp
void show(const char* str, int width);
void show(double d, int width);
void show(long l, int width);
```

注意如果使用了与目标参数类型不匹配的函数调用，如声明一个`int`类型变量`year`并调用`show(year, 2)`，编译器会尝试使用标准类型转换强制进行转换，而重载的函数中有两条原型的第一个参数是整型类型，编译器将不知道转换为哪一条，所以会抛出错误。但是当重载函数原型只有一条可供强制转换时，不会抛出这样的错误。

注意函数重载**不区分类型引用和类型本身**，也不区分函数的返回类型，也不区分变量是否为`const`变量。但是对于类中的成员函数，可以通过`const`限定符进行区分：

``` cpp
class MyLine {
    private:
        double xPoint;
        double yPoint;
    public:
        double calRotate(double x, double y) {
            double tan = x / y;
            return atan(tan);
        }
        double calRotate(double x, double y) const {
            double tan = x / y;
            return atan(tan);
        }
};
```

编译器能够识别不同函数特征标的重载函数的方法是**名称修饰**或者**名称矫正**，它根据函数原型中指定的形参类型对每个函数名进行加密，这在编译器内部将作为函数的接口编码，且编码方式因编译器而异：

``` cpp
long MyFunctionFoo(int, float) // ?MyFunctionFoo@@YAXH
```

### 6.11 函数模板

函数模板是通用的函数描述，它们使用**泛型**来定义函数，其中的泛型可以用具体的类型进行替换。通过将类型作为参数传递给模板，编译器将生成该类型的函数。函数模板允许以任意类型的方式来定义函数：

``` cpp
template <typename T>
void swap(T& a, T& b) {
    T temp;
    temp = a;
    a = b;
    b = temp;
}

int main() {
    double a = 1314.520;
    double b = 1145.140;
    int u = 0;
    int v = 1;
    std::cout << swap(a, b) << std::endl;
    std::cout << swap(u, v) << std::endl;
}
```

关键字`template`和`typename`是必需的，且必须使用尖括号将泛型和泛型类型名括起。上面的模板语句`template <typename T>`也可以改成`template <class T>`。使用函数模板与使用函数是一样的，编译器将自动生成符合参数类型的具体函数。函数模板并不能缩短可执行程序，但是可以使生成的多个函数定义更简单更可靠。

可以像重载常规函数一样重载模板定义，和常规函数的重载一样，被重载的模板的函数特征标也必须不同：

``` cpp
template <typename T>
void swap(T& a, T& b);
void swap(T a[], T b[], int n);
```

在代码中包含函数模板并不会生成函数定义，它是一个用于生成函数定义的方案。编译器使用模板为特定类型生成函数定义时得到的是**模板实例**，这种模板实例是函数定义。这种实例化方式称为**隐式实例化**。C++允许**显式实例化**，其语法是使用`<>`符号指示类型，并在声明前加上关键字`template`。也可以在函数调用的时候创建显式实例化。

``` cpp
template void swap<int>(int, int);
int main() {
    add<double>(a, b);
}
```

模板的**显式具体化**指的是模板的具体化函数定义，当编译器找到与函数调用匹配的具体化定义时，将使用该定义而不再寻找模板。C++98规定，对于给定的函数名，可以有它的**非模板函数**（正常定义的函数）、**模板函数**、**显式具体化模板函数**以及它们的重载版本。编译器匹配调用的函数顺序：显式具体化优先于常规模板函数，非模板函数优先于显式具体化与常规模板函数。

显式具体化模板函数的原型使用`template<>`开头，并通过名称来指出类型（名称可以省略）：

``` cpp
template <typename T>
void swap(T&, T&);
template <> void swap<wife>(wife& a, wife& b);
// template <> void swap(wife& a, wife& b);
template <> void swap<wife>(wife& a, wife& b) {
    std::string tempname;
    int tempage;
    tempname = a.name;
    a.name = b.name;
    b.name = tempname;
    tempage = a.age;
    a.age = b.age;
    b.age = tempage;
}
```

既然C++对于给定的函数名支持如此多函数定义方式，编译器就必须知道使用哪个函数定义。这个过程称为**重载解析**，其过程大致如下：
- 创建候选函数列表，其中包含与被调用函数的名称相同的函数和模板函数；
- 使用候选函数列表创建可行函数列表。都是参数数目正确的函数，并且有隐式的类型转换发生；
- 确定是否有最佳的可行函数，如果有则调用，如果没有将发生调用错误。

编译器将比较可行的函数列表中是否存在最佳的，判定最佳函数的优先顺序如下：
- 完全匹配，但是常规函数优先于模板；
- 提升转换：例如`char`和`shorts`自动转换为`int`，`float`自动转换为`double`；
- 标准转换：例如`int`转换为`char`，`long`转换为`double`；
- 用户定义的转换，如类声明中定义的转换。

进行完全匹配的时候，C++允许「无关紧要」的转换：

|实参|形参|说明|
|:---:|:---:|:---:|
|`Type`|`Type&`|`Type`类型与其引用完全匹配|
|`Type&`|`Type`|`Type`类型与其引用完全匹配|
|`Type[]`|`*Type`|数组`Type`与指针（可以进行指针算术）`*Type`完全匹配|
|`Type(argument-list)`|`Type(*)(argument-list)`|`Type`是一个函数名，用作实参的函数名与用作形参的函数指针只要参数列表相同就完全匹配|
|`Type`|`const Type`|`Type`类型与其常量类型完全匹配（下同）|
|`Type`|`volatile Type`|/|
|`Type*`|`const Type*`|/|
|`Type*`|`volatile Type*`|/|

如果有多个匹配的原型，则编译器将无法完成重载解析过程；如果没有最佳的可行函数，则编译器将生成一条错误消息，可能是「二义性」或者「重定义」错误。

如果多个匹配的原型都是模板函数，则编译器将选择最具体的模板函数。术语「**最具体**」不一定意味着显式具体化，它指的是编译器推断使用哪种类型时执行的转换最少：

``` cpp
template <class Type> double calRotate(Type t);     // #1
template <class Type> double calRotate(Type* t);    // #2
// Other code
struct MyLine {
    double xPoint;
    double yPoint;
};
MyLine mainLine = {12.3, 12.4};
std::cout << calRotate(&mainLine); 
```

上述代码`calRotate`函数传递的实参是结构变量`mainLine`的地址，在编译器显式具体化模板函数匹配的时候，第二个函数需要经过的变换更少，对于该调用而言更具体。

总结，重载解析的顺序如下：
- 如果函数名只存在一个函数，则选择它；
- 如果函数名存在多个函数，但是其中只有一个是非模板函数，则选择它；
- 如果函数名存在多个适合的函数，且它们都是模板函数，但其中有一个函数比其他函数都具体，则选择它；
- 如果函数名存在多个适合的非模板函数**或**模板函数，但没有一个函数比其他函数更具体，则函数调用是不确定的，将发生调用错误。


模板函数发展的过程中也有比较麻烦的问题：假设模板原型定义了两种模板类型，在一个函数中这两种模板类型产生了运算交互并赋值给一个变量，则这个变量的类型应该是什么？C++11新增的关键字`decltype`解决了这一问题：

``` cpp
template<class Type1, class Type2>
void sum(Type1 x, Type2 y) {
    sum = x + y;    // What is the type of sum?
    decltype(x + y) sum = x + y;
    // decltype(expression) var
    typedef decltype(x + y) xytype;
    xytype sumsum = 2 * x + 2 * y;
}
```

关键字`decltype`指的是将其括号内的表达式值或变量的类型声明给紧跟其后的变量，这里`x + y`的类型将由编译器根据类型提升决定。可以配合使用`typedef`进行多次声明。
- 第一步：如果`expression`是一个没有用括号括起的标识符，则`var`的类型与标识符的类型相同；
- 第二步：如果`expression`是一个函数调用，实际上并不会调用函数，编译器将通过查看函数的原型获取函数返回类型，`var`的类型与函数的返回类型相同；
- 第三步：如果`expression`是一个左值，并且不能是未用括号括起的标识符，则`var`为指向其类型的引用；
- 第四步：如果前面几步都不满足，则`var`的类型与`expression`的类型相同。

``` cpp
double x = 1.32;
const double* yPointer;
double average(const int input[]);
decltype(x) xx;         // xx is type double
decltype(yPointer) yy   // yy is type const double*
decltype(average[z]) zz // zz is type double
decltype((x)) xxx       // xxx is type double&
```

但是单靠`decltype`无法解决函数返回类型未知的问题，而这可以结合C++11新增的`auto`的用法以及**后置返回类型**解决。`auto`是一个占位符，它将函数的返回类型移动到参数声明之后，`->`及紧跟其后的类型称为后置返回类型（这里需要后置的原因是`decltype`需要知道参数`x`和`y`的类型）：

``` cpp
template<class Type1, class Type2>
auto sum(Type1 x, Type2 y) -> decltype(x + y) {
    return x + y;
}
```

## 7 内存模型和名称空间

### 7.1 单独编译

C/C++建议将程序分为几个部分：
- 头文件：包含结构声明和使用这些结构函数的原型；
- 源代码文件：包含与结构有关的函数的代码；
- 源代码文件：包含调用与结构相关的函数的代码。

头文件中常包含的内容有：函数原型、使用`#define`或`const`定义的符号常量、结构声明、类型声明、模板声明、内联函数。在包含头文件时，不应该使用尖括号而应该使用双引号：`#include "MyFrame.h"`。文件名包含尖括号时C++编译器将在存储标准头文件的主机系统的文件系统中查找，如果文件使用双引号，则将首先查找工作目录或源代码目录，如果没有再去标准位置查找。**因此在包含自己的头文件时应该使用引号而不是尖括号**。注意不能使用`#include`预编译指令包含源代码文件，这将导致多重声明。

UNIX系统中编译头文件和源代码文件的过程如下：
- 预处理器将包含的头文件（`header.h`）和源代码文件（`file1.cpp`和`file2.cpp`）进行合并成两个临时文件；
- 编译器创建每个源代码文件的目标代码文件（`file1.o`和`file2.o`）；
- 链接程序将目标代码文件、库代码和启动代码合并，生成可执行文件`a.out`。

gcc编译多个源文件需要的指令如下：

``` shell
gcc -c file1.cpp file2.cpp
g++ file1.o file2.o -o file
```

一种标准的C/C++技术可以避免多次包含同一个头文件，它是基于预处理器编译指令`#ifndef`（`if not define`）的，下面的代码意味着仅当之前没有使用预处理器编译指令`#define`定义名称`My_H_`时，才处理`#ifndef`与`#endif`之间的语句：

``` cpp
#ifndef My_H_
#define My_H_
...
#endif
```

### 7.2 存储持续性、作用域和链接性

C++11中使用四种不同的方案来存储数据，这些方案的区别在于数据保留在内存中的时间：
- **自动存储持续性**：在函数定义中声明的变量以及函数参数的存储持续性是自动的，它们在程序开始执行其所属的函数或者代码块时被创建，在执行完函数或者代码块时，它们使用的内存被释放；
- **静态存储持续性**：在函数定义外定义的变量或者使用`static`定义的变量的存储持续性都为静态的，它们在程序的整个运行过程都存在；
- **线程存储持续性**：该存储方案是C++11的内容，多核处理器CPU可以同时处理多个执行任务，程序可以将计算放在可并行处理的不同线程中。如果变量是使用`thread_local`声明的，则其生命周期与所属的线程一样长；
- **动态存储持续性**：用`new`运算符分配的内存将一直存在，直到使用`delete`运算符将其释放或者程序结束为止。这种内存的存储持续性为动态，有时被称为**自由存储**或者**堆**。

**作用域**描述了名称在文件的多大范围内可见，作用域为局部的变量只能在定义它的代码块中使用（代码块指的是使用`{}`包裹起来的一系列语句），作用域为全局的变量在定义位置到文件末尾都能使用。**链接性**描述名称在不同单元时间如何共享，链接性为外部的名称可以在文件之间共享，链接性为内部的名称只能由一个文件中的函数共享。

#### 7.2.1 自动存储持续性

默认情况下，在函数内部声明的函数参数以及变量的存储持续性是自动的，**作用域为局部**，**没有链接性**。在代码块中定义的变量的存在时间以及作用域都限制在该代码块内。`auto`关键字在**过去的C/C++标准中**可以用于显式地指出变量为自动存储，而这在C++11中已经不再合法。

``` cpp
void function(double x, double y) {
    int number = 10;
    std::cout << number << std::endl; // = 10
    {
        int number = 8;
        // This number is different from the number outside
        std::cout << number << std::endl; // = 8
    }
    std::cout << number << std::endl; // = 10
}
```

程序在运行时对自动变量进行管理，常用的方法是留出一段内存将其视为**栈**，栈中的新数据被象征性地放在原有数据的上面（相邻的内存单元而不是同一个内存单元），当程序使用完后将其从栈中删除。程序使用两个指针来跟踪栈，一个指针指向栈底，栈的开始位置，另一个指针指向栈顶，下一个可用的内存单元。当函数被调用时，其自动变量将被加入到栈中，栈顶指针指向变量后面的下一个可用的内存单元，函数结束时，栈顶指针被重置为函数被调用前的值，从而释放了函数内的变量（实际上内存中的内容并没有被删除，但是不再被标记）。

#### 7.2.2 静态存储持续性

C++为静态存储的持续性变量提供了三种链接性：外部链接性（可以在其他文件中访问）、内部链接性（只能在当前文件中访问）和无链接性（只能在当前函数或者代码块中访问）。这三种链接性在程序的运行期间都存在，与自动变量相比它们的寿命更长。静态变量的数目在程序运行期间不会发生变化，编译器将分配固定的内存块来存储所有的静态变量。
- 代码块外部声明的变量为具有**外部链接性**的静态变量；
- 代码块外部，使用关键字`static`声明的变量为具有内部链接性的静态变量；
- 代码块内部，使用关键字`static`声明的变量为具有无链接性的静态变量。 

静态变量的初始化有三种：
- 默认的**零初始化**：未被初始化的静态变量的所有位都被设置为零。对于标量类型，零被强制转换为合适的类型，例如空指针表示为`0`，但其内部可能是非零表示；
- **常量表达式初始化**：首先所有的静态变量都会被零初始化而不管程序员是否显式地初始化它。如果使用常量表达式初始化变量，且编译器仅根据文件内容就可计算表达式，编译器将执行常量表达式初始化；
- **动态初始化**：当没有足够的信息用于初始化静态变量时，编译器将动态初始化静态变量。

C++有**单定义规则**：变量只能有一次定义。为满足单定义规则，C++提供两种变量声明，一种是**定义声明**或简称为**定义**，它给变量分配存储空间；另一种是**引用声明**或简称**引用**。引用声明使用关键字`extern`且不进行初始化：

``` cpp
double up = 12.3;   // defining declaration
extern double down; // referencing declaration
```

如果在代码块内部定义了与全局变量同名的自动变量，则自动变量将把全局变量隐藏起来。可以在变量名前加上作用域符`::`使用全局变量：

``` cpp
double degree = 13.0;

int main() {
    std::cout << degree << '\n';
    double degree = 12.0;
    std::cout << degree << '\n';
    std::cout << ::degree << '\n';
    return 0;
}
```

如果文件中定义了静态外部变量，其名称与另一个文件中声明的常规外部变量相同，则在该文件中，静态变量将隐藏常规外部变量。这没有违背单定义规则，因为关键字`static`指出标识符的链接性为内部，并非要提供外部定义。

``` cpp
// File1.cpp
int global = 12;

// File2.cpp
extern int global;  // Use the global variable with keyword 'extern'
static int global;  // Redefine the variable with keyword 'static' 
```

接下来介绍定义在代码块内部定义，没有链接性的局部变量，这种变量同样使用`static`关键字进行声明。该类型的局部变量的存储持续性是静态的，只能在该代码块中使用，但是它在该代码块不处于活动状态时仍然存在，在代码块两次调用之间，静态局部变量的值将保持不变。在代码块第一次被调用时，静态变量将被初始化，此后的调用中静态变量将不会经过新的初始化。

``` cpp
void function(int n) {
    static int count;
}
```

#### 7.2.3 说明符与限定符

- `const`限定符表明内存被初始化后，程序不能再对该内存进行修改。在C++（C语言没有这样的语法）中，`const`限定符对默认存储类型有影响，在默认情况下全局变量的链接性是外部的，**但`const`全局变量的链接性是内部的**，在C++看来`const`就像使用了`static`说明符。这主要是因为如果在头文件中使用`const`限定了变量，预处理器将把头文件中的定义包含到每个源文件中，这违反了单定义规则。如果出于某种原因，需要`const`变量具有外部链接性，可以使用`extern`关键字覆盖默认的内部链接性，但同时需要注意在所有使用了该常量的文件中使用`extern`关键字引用声明它（除了头文件中声明的，如以下的`SITUATION_1`中可以直接使用定义在头文件中的常量）：

    ``` cpp
    // #ifndef SITUATION_1
    // #define SITUATION_1
    // Header.h
    extern const int CONST_NUMBER

    // File1.cpp
    #include "Header.h";
    const int CONST_NUMBER = 12;

    // File2.cpp
    int main() {
        std::cout << CONST_NUMBER;
    }
    // #endif // ~SITUATION_1

    // #ifndef SITUATION_2
    // #define SITUATION_2
    // File1.cpp
    extern const int CONST_NUMBER = 12;

    // File2.cpp
    extern const int CONST_NUMBER;
    // #endif // ~SITUATION_2 
    ```
- `volatile`关键字表明即使程序没有对内存单元进行修改，其值也可能发生变化。当两个程序共享一些内存单元时，使用该关键字可以改变编译器的优化能力。假设编译器发现程序在多条语句中使用了某个变量的值，它可能不会让程序查找这个值两次而是将这个值缓存在寄存器中，这种优化会使得这个变量的值在两次调用过程中不发生变化。使用`volatile`关键字使得编译器的优化不再进行。
- `mutable`关键在表明即使变量为`const`，但其某个变量成员还可以被修改：

    ``` cpp
    struct wife {
        int age;
        std::string name;
        mutable std::string work;
    };
    ```

#### 7.2.4 函数、语言的链接性

C++中的函数也具有链接性，因为C++不允许在函数内部定义一个新的函数，所以所有函数的存储持续性都自动为**静态**。默认情况下函数的链接性是外部的，可以在文件之间共享，实际上可以在函数原型前使用关键字`extern`来指出函数是在另一个文件中定义的。**可以使用关键字`static`将函数的链接性设置为内部**，使之只能在一个文件中使用，注意必须在函数原型和函数定义中都使用关键字`static`。

``` cpp
static void function(int n);
static void function(int n) {
    // Other code
}
```

单定义规则同样适用于**非内联函数**，对于每一个非内联函数，程序只能包含一个定义。

链接程序和编译器要求每个不同的函数都拥有不同的**符号名**，例如C语言编译器可能将函数`function`的符号名翻译为`_function`，但是C++中有函数的重载，它要求根据函数特征标区分同样的函数名，所以C++编译器可能将函数`void function(int n, char input[])`的符号名翻译为`v_function@i_c[]`，如果要在C++程序中使用C库中预编译的函数时就会出现错误。一种解决办法是使用关键字`extern`解决C和C++之间语言链接性的不同，它后面的字符串指明进行符号名翻译时使用的方式：

``` cpp
extern "C" void function(int n, char input[]);
extern "C++" double nude(int n);
```

#### 7.2.5 动态存储持续性

动态存储中变量在内存中持续的时间由`new`和`delete`的使用决定。编译器使用三块独立的内存：一块用于静态变量，一块用于自动变量，另一块用于动态存储。

要为内置的标量类型分配存储空间并初始化，可以使用以下句法：`type* name = new type (value);`，这种括号语法也可以适用于有合适构造函数的类。如果需要初始化常规结构以及数组，则需要使用大括号的列表初始化：

``` cpp
struct wife {
    int age;
    double height;
    std::string name;
};

wife* wife_2023 = new wife [3] = {
    {12, 156.23, "Izumi Sagiri"},
    {14, 146.24, "Shuna"},
    {14, 150.34, "Elaina"}
};
```

在较老的实现中，`new`找不到请求的内存量时将返回空指针，现在将引发异常`std::bad_alloc`。`new`、`new[]`、`delete`和`delete[]`的工作原理如下，它们将调用以下函数（被称为分配函数与释放函数）：

``` cpp
void* operator new(std::size_t);
void* operator new[](std::size_t);
void* operator delete(std::size_t);
void* operator delete[](std::size_t); 
```

通常`new`运算符用于在堆中找到一块足以满足要求的内存块，但是`new`还有一种称为**定位`new`运算符**的变体，它能够在指定的位置上的内存块存储变量的值。要使用定位`new`运算符，需要包含头文件`<new>`，此时变量后的方括号可以有也可以没有。

``` cpp
#include <iostream>
#include <new>

const int BUFFERSIZE = 1024;
const int N = 5;
char buffer[BUFFERSIZE];

int main() {
    double* pd1, * pd2;
    std::cout << "Calling new and placement new:\n";
    pd1 = new double[N];
    pd2 = new (buffer) double[N];
    for (int i = 0; i < N; i++)
        pd1[i] = pd2[i] = 1000 + 20 * i;
    std::cout << "Memory address:\n" << "heap:  " << pd1
              << "  static:  " << (void*) buffer << std::endl;
    std::cout << "Memory contents:\n";
    for (int i =0; i < N; i++) {
        std::cout << pd1[i] << "  at  " << &pd1[i] << ";  ";
        std::cout << pd2[i] << "  at  " << &pd2[i] << std::endl;
    }
    return 0;
}
```

以上程序示例中使用静态数组`buffer`为`double`类型的动态数组分配了内存，注意这种定位`new`运算符分配的内存不能使用`delete`进行释放，否则将发生运行阶段错误。释放定位`new`运算符分配的内存需要**显式地调用变量对应类型的析构函数**，需要注意的点是正确的删除顺序是和创建顺序是相反的（因为后创建的可能依赖于前面先创建的变量），并且只有在所有变量都释放之后才能删除缓冲区：

``` cpp
for (int i = N - 1; i >= 0; i--) {
    pd2[i].~double();
}
```

### 7.3 名称空间

- **声明区域**：在函数外部声明的全局变量，对于这种变量，其声明区域为其声明所在的文件；对于在函数中声明的变量，其声明区域为其声明所在的代码块；
- **潜在作用域**：变量的潜在作用域从声明点开始一直到其声明区域的结尾，因此潜在作用域的大小比声明区域小，这是由于变量必须定义后才能使用；
- **作用域**：变量对程序而言可见的范围被称为作用域，它要小于潜在作用域的大小。在一些代码块中可能存在同名的变量，这将隐藏外界变量，对外界变量而言该代码块不是作用域。

C++中每一个声明区域都可以声明名称，且独立与其他声明区域中的名称。C++新增了一种新的声明区域来创建新的命名空间，这样做的目的是防止与其他名称空间中的相同名称发生冲突，这种声明区域称为**名称空间**。除了用户定义的名称空间，还存在**全局名称空间**，它对应于文件级声明区域，全局变量位于全局名称空间中。

使用作用域解析符`::`对名称空间内的名称进行使用，对于全局名称空间，作用域解析符前不需要名称空间的名称（全局名称空间不具有名称）。

``` cpp
namespace TunnelInfo {
struct Position {
    double x;
    double y;
};

class Tunnel {
    private:
        double height;
        double width;
        std::string name;
        Position pos;
    public:
        Tunnel(double h, double w, std::string n, Position p) {
            height = h; width = w; name = n; pos = p;
        }
        ~Tunnel() = default;
        void OnShowPosition() {
            std::cout << "The x position is " << pos.x << "\n"
                      << "The y position is " << pos.y << "\n";
        }
};
}

int main() {
    TunnelInfo::Tunnel Chicago(8.2, 15.6, "Chicago Highway Tunnel", {34.23, 12.40});
    Chicago.OnShowPosition();
    return 0;
}
```

名称空间可以进行嵌套，同时嵌套使用作用域解析符获取内部名称空间的名称：

``` cpp
namespace THUinfo {
namespace THUsudent {
struct date {
    int year;
    int month;
    int day;
};
struct student {
    long id;
    std::string name;
    date getInDate;
};
}   // THUsdudent
}   // THUinfo

int main() {
    // using namespace THUinfo::THUstudent
    THUinfo::THUstudent::student student[1000];
    student[0].id = 2022012050;
    return 0;
}
```

如果名称空间中使用别的名称空间的`using`编译指令，则使用该名称空间的`using`编译指令也包含使用了别的名称空间的`using`编译指令：

``` cpp
namespace THUinfor {
    using namespace THUstudent
}
```

可以通过省略名称空间的名称创建未命名的名称空间，在该名称中声明的名称的潜在作用域是从声明点到该声明区域结尾。由于这种名称空间没有名称，因此在别的文件中的不能显式地调用该名称空间内的名称，于是这提供了**链接性为内部的静态变量的替代品**。

``` cpp
namespace {
    double counts;  // = static double counts;
}
```

## 8 对象和类

### 8.1 抽象和类

<br>    

**类**是一种将抽象转换为用户定义类型的C++工具，它将数据表示和操纵数据的方法组合成一个整合的包。类规范由两个部分组成：
- **类声明**：以数据成员的方式描述数据部分，以成员函数（或称方法）的方式描述公有接口；
- **类方法定义**：描述如何实现类成员函数。

通常，C++程序员将接口（类定义）放在头文件中，并将实现（类方法的代码）放在源代码中。头文件的后缀名为`.h`。其常见的结构为：

``` cpp
class stock {
    private:
        std::string company;
        long shares;
        double share_val;
        double total_val;
        void set_tot() {
            total_val = shares * share_val;
        }
    public:
        void acquire (const std::string & co, long n, double pr);
        void buy (long num, double price);
        void sell (long num, double price);
        void update (double price);
        void show ();
};
```

首先C++关键字`class`指出这些代码定义了一个类设计，`stock`是这个新类的类型名，该声明能够让我们声明给类型的变量（被称为**对象**或者**实例**）。**类成员可以是数据类型，也可以是函数**。关键字`private`和`public`描述了对类成员的访问控制，使用类对象的程序都可以直接访问公有部分，但只能通过公有成员函数或友元函数访问对象的私有成员，这样的**数据隐藏**防止直接访问数据导致的数据损坏。

根据OOP（面向对象编程）的精神，常把数据项放在`private`中，而把组成类接口的成员函数放在`public`中。但是`private`关键字不是必需的，因为这是类对象的默认访问控制。

成员函数的定义与常规函数的定义是类似的，都有函数头和函数体，也有返回类型和参数，但成员函数具有两个特征：
- 定义成员函数时，使用作用域解析运算符（`::`）标识函数所属的类；
- 类方法可以访问类的`private`组件。

``` cpp
void stock::acquire(const std::string & co, long n, double pr) {
    company = co;
    if (n < 0) {
        std::cout << "Number of shares can't be negative;"
            << company << "shares set to 0.\n";
        shares = 0;
    }
    else {
        shares = n;
    }
    share_val = pr;
    set_tot();
}
```

定义位于类声明中的函数称为**内联函数**，类声明常将短小的成员函数作为内联函数，在上例中`set_tot()`函数就是内联函数。也可以在类声明外部定义内联函数，但需要使用`inline`限定符：

``` cpp
inline void stock::set_tot() {
    total_val = shares * share_val;
}
```

当创建了类`stock`的对象`sagiri`时，则可以通过`sagiri.show()`调用对象中的内部数据与成员。**所创建的每个新对象都有自己的存储空间**，用于存储其内部变量和成员（它们所处的内存地址不一样），但所有创建的对象共用同一组类方法。在OOP中，调用成员函数被称为**发送消息**。

将类的句法格式抽象可得：

``` plaintext
class className {
    private:
        data member declarations
    public:
        member function prototypes
};
```

### 8.2 类的构造函数和析构函数

#### 8.2.1 声明和定义构造函数

类的构造函数的功能是**将参数传递给类中的内部数据**（因为一般来说类的内部数据是不可访问的）。当创建构造函数时，**不能使用返回类型，并且原型位于`public`部分**。当然可以使用一个返回类型为`void`（实际没有返回值，但是这和构造函数不同）替代构造函数，但是在**程序声明对象时，将自动调用构造函数**。

``` cpp
#include <iostream>
#include <cstring>

class wife {
    private:
        int age_past;
        int work_year;
        int age_today;
        std::string name;
        std::string appearwork;
    public:
        wife(const int ap, int wy, std::string n, std::string a) {
            age_past = ap;
            work_year = wy;
            name = n;
            appearwork = a;
        };
        wife() {};
        ~ wife() {};
        void show();
};
```

使用构造函数只需要在初始化时进行即可，C++提供了两种使用方式：
- 显式调用构造函数

    ``` cpp
    wife sagiri = wife(12, 2017, "Izumi Sagiri", "Eromanga Sensei");
    ```
- 隐式调用构造函数
    
    ``` cpp
    wife sagiri(12, 2017, "Izumi Sagiri", "Eromanga Sensei");
    ```
- 列表初始化调用构造函数
    
    ``` cpp
    wife sagiri = {12, 2017, "Izumi Sagiri", "Eromanga Sensei"};
    wife sagiri {12, 2017, "Izumi Sagiri", "Eromanga Sensei"};
    ```
- 赋值语句调用构造函数并创建临时对象
    
    ``` cpp
    wife sagiri;
    sagiri = wife(12, 2017, "Izumi Sagiri", "Eromanga Sensei");
    ```
- 只有一个参数的构造函数可不使用括号进行赋值
    
    ``` cpp
    wife sagiri;
    sagiri = "Izumi Sagiri";
    // sagiri(std::string c_name);
    ```

构造函数还可以使用特殊的成员初始化列表完成构造的工作，这种语法可以用于`const`类型的数据成员以及声明为引用的赋值（数据成员被初始化的顺序与它们出现在类声明中的顺序相同，与初始化器中的排列顺序无关）：

``` cpp
wife(const int ap, int wy, std::string n, std::string a) : 
    age_past(ap),
    work_year(wy), 
    name(a),
    age(a) {};
```

#### 8.2.2 默认构造函数

默认构造函数是在未提供显式初始值时，用来创建对象的构造函数，例如初始化创建对象的语句为`wife sagiri`时C++自动提供默认构造函数。它是默认构造函数的隐式版本，不做任何工作：

``` cpp
wife::wife() {}
```

当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数；如果定义了构造函数，则C++不会提供默认构造函数，若对象初始化时未提供显式初始值，则会抛出错误，因此，在提供了构造函数的时候，还应当由程序员手动添加默认构造函数。**隐式调用默认构造函数时不要加括号**。也可以由程序员手动添加带有参数的的显式默认构造函数，此时构造函数中的参数都应该有默认值：

``` cpp
TableTennisPlayer(const std::string& fn = "None",
                  const std::string& ln = "None",
                  bool ht = false);
```

构造函数的参数名和类中的成员名经常是相同的，而这会导致出现类似`name = name`这样的语句，所以可以将构造函数内的参数名设置为`c_name`这样的含前缀的名称，或者使用类内成员名的简写。

#### 8.2.3 析构函数

用构造函数创建对象后，程序将持续跟踪该对象。当对象过期时，程序将调用一个特殊的成员函数：析构函数，并用于完成清理工作。如果构造函数使用`new`来分配内存，则析构函数则将使用`delete`释放内存。如果没有构造函数使用`new`来分配内存，则析构函数实际上没有需要完成的任务，此时生成的是一个什么也不做的**隐式析构函数**。

析构函数的名称是在类名之前加一个`~`：

``` cpp
~ wife() {};
```

通常不应在代码中显式地调用析构函数，因为一般来说析构函数将被自动调用：
- 如果创建的是静态存储类对象，则其析构函数将在程序结束时自动被调用；
- 如果创建的是自动存储类对象，则其析构函数将在程序执行完代码块时自动被调用；
- 如果对象是通过`new`创建的，则该对象将驻留在栈内存中或自由存储区中，当使用`delete`来释放内存时，其析构函数将自动被调用；
- 如果对象是程序临时创建的，程序将在结束对该对象的使用时自动调用其析构函数。

对于以下语句，C++编译器将拒绝执行`sagiri.show()`语句：

``` cpp
const wife sagiri(12, 2017, "Izumi Sagiri", "Eromanga Sensei");
sagiri.show();
```

这是因为C++编译器无法保证`show()`函数的代码确保调用对象不被修改，调用的数据成员和被常量化的对象一样不应该被修改。要保证函数不会修改对象，需要将`const`关键字放在函数的括号后面：

``` cpp
void wife::show() const {
    std::cout << "Your wife " << name << "'s appearwork is " << 
        appearwork << std::endl;
    std::cout << "  She is " << age_past << 
        " years old in " << work_year << std::endl;
    std::cout << "  And she is " << age_today <<
        " years old now." << std::endl;
}
```

此时函数内部不能含有修改调用的数据成员的语句。

### 8.3 `this`指针

如果需要比较一个类中的两个对象的成员数据，需要将其中一个对象作为参数传递给另一个对象：

``` cpp
// test.h
const wife& min_age(const wife& s) const;

//test.cpp
const wife& wife::min_age(const wife& another_wife) const {
    if (another_wife.age_past < age_past) {
        std::cout << "Your younger wife is " << another_wife.name << std::endl;
        return another_wife;
    }
    else {
        std::cout << "Your younger wife is " << name << std::endl;
        return *this;
    }
}
```

该函数将访问传入参数所指内存块中存储的对象，但是不更改这个对象内的所有数据成员（传入的参数被关键字`const`约束），它还将隐式地访问它所在类中的对象，它还将返回一个对象的引用。使用这个函数的方法如下：

``` cpp
soller.min_age(sagiri);
sagiri.min_age(soller);
```

上述代码中出现的指针`*this`指向用来调用成员函数的对象，被用于隐藏参数传递给方法。其中`this`是指该对象的地址。

### 8.4 对象数组

声明对象数组的方法与声明标准类型数组是一致的，如`wife loli_wife[10];`。每个元素都是一个`wife`对象，可以使用`wife`内的方法。对象数组的初始化可以用列表初始化，花括号内要对每一个对象都是用构造函数：

``` cpp
wife loli_wife[10] = {
    wife(12, 2017, "Izumi Sagiri", "Eromanga Sensei"),
    wife(9, 2022, "Charlotte Soller", "Isekai Pharmacy")
};
```

这段程序只初始化了`loli_wife[0]`和`loli_wife[1]`对象，剩余的数组元素使用默认构造函数初始化。初始化对象数组的过程：首先使用默认构造函数创建数组元素，然后花括号内中的构造函数创建临时对象并将临时对象的内容复制到相应的元素中。

### 8.5 类作用域

在类中定义的名称（类数据成员名和类成员函数名）的作用域是整个类，这些名称在类中是已知的，但是在类外是不可知的。创建一个由所有对象共享的常量不能直接使用`const`关键字：

``` cpp
class wife {
    private:
        const int LAW_AGE = 14;
};
```

这样使用`const`关键字将导致错误，因为声明类只是描述了对象的形式，并没有创建对象，因此也没有用于存储该常量的内存。但是有两种方式可以达到定义常量的效果：
- 在类中使用`enum`创建枚举：
    ``` cpp
    class wife {
        private:
            enum {LAW_AGE = 14};
    };
    ```
    在这里并没有指定枚举的名称，因为这里不需要创建一个枚举型的变量，只是为了创建符号常量，也不会创建类数据成员，所有对象都不包含`LAW_AGE`这样的数据成员，`sagiri.LAW_AGE`这样的语句是错误的。

- 使用`static`关键字定义常量：
    ``` cpp
    class wife {
        private:
            static const int LAW_AGE = 14;
    };
    ```

C++11提供了一种新的枚举，为了防止出现不同枚举中的符号常量重名导致编译不通过的问题，C++11定义了作用域为类的新枚举——枚举类，定义这些类枚举可以使用`class`或`struct`关键字：

``` cpp
enum class footsize {SMALL, MEDIUM, LARGE, XLARGE};
enum struct juicecup {SMALL, MEDIUM, LARGE};
```

使用这些符号常量需要使用作用域解析运算符`::`，例如`footsize::XLARGE`。可以指定符号常量的整型类型（默认为`int`）：

``` cpp
enum class:long planetDistance {MERCURY, VENUS, EARTH, MARS};
```

### 8.6 运算符重载

运算符的重载与函数的重载的含义是一致的，这会赋予同一个运算符多种含义，编译器根据执行运算符的变量、常量或对象的类型判断应该使用哪种含义的运算符。要实现重载运算符，需使用**运算符函数**这种特殊函数形式，格式如下：

``` plaintext
operator op (argument-list) {
    body
}
```

其中`op`应当是C++中有的运算符，不能使用其他运算符，例如`operator+()`，`operator-()`这样的格式是正确的，`operator@()`这样的格式则是错误的。编写运算符函数与编写正常成员函数是一致的。

``` cpp
complex complex::operator + (const complex& c) const {
    complex sum;
    sum.real = real + c.real;
    sum.imaginary = imaginary + c.imaginary;
    return sum;
};
complex complex::operator - (const complex& c) const {
    complex minus;
    minus.real = real - c.real;
    minus.imaginary = imaginary - c.imaginary;
    return minus;
};
complex complex::operator * (const complex& c) const {
    complex times;
    times.real = real * c.real - imaginary * c.imaginary;
    times.imaginary = real * c.imaginary + imaginary * c.real;
    return times;
};
complex complex::operator / (const complex& c) const {
    complex divides;
    divides.real = (real * c.real + imaginary * c.imaginary) / (pow(c.real, 2) + pow(c.imaginary, 2));
    divides.imaginary = (- real * c.imaginary + imaginary * c.real) / (pow(c.real, 2) + pow(c.imaginary, 2));
    return divides;
};
```

重载也有一些限制：
- 重载后的运算符必须至少有一个操作数是用户定义的类型，防止用户为标准联系定义重载运算符而导致混乱；
- 使用运算符时不能违反运算符原来的句法规则，例如不能将求模运算符`%`作为一个操作符；
- 不能修改运算符的优先级；
- 不能重载以下运算符（以下所列不全）：
  - `sizeof`：`sizeof`运算符；
  - `.:`：成员运算符；
  - `.*:`：成员指针运算符；
  - `::`：作用域解析运算符；
  - `?:`：条件运算符。

<br>  

### 8.7 友元

以上复数类的程序中还缺少复数与实数相乘的运算，而这一运算符只用重载运算符时只能实现一定顺序的相乘：

``` cpp
complex operator*(double x) const {
    complex times;
    times.real = x * real;
    times.imaginary = x * imaginary;
    return times;
};
```

语句`complex_1 * 2`是正确的，因为这等价于`complex_1.operator*(2)`，而语句`2 * complex_1`则是错误的。

#### 8.7.1 友元函数

为了解决以上出现的问题，要使顺序未定义的运算符也能正常运行，需要定义友元函数，第一步是将友元函数的原型放在类声明中，并在原型声明前加上关键字`friend`：

``` cpp
friend complex operator*(double x, const complex& c);
```

该声明意味着两点：一是该函数是非成员函数，不能使用成员运算符调用；二是它虽然不是成员函数，但它的访问权限与成员函数是相同的。接下去要对该函数进行定义，此时定义不应该使用作用域限定符`::`和关键字`friend`（当然在函数原型之上也可以直接定义）。

``` cpp
complex operator*(double x, const complex& c) {
    return c * x;
};
```

常用的运算重载符是`<<`，一般可以使用`cout`对象（它在名称空间`std`下的`ostream`类中）对应的友元函数进行重载，使之可以使用`cout`对象输出原来不能直接输出的格式，在以下代码的基础上可以使用语句`std::cout << complex_1`：

``` cpp
friend void operator<<(std::ostream& os, const complex& c) {
    if (c.real == 0) {
        std::cout << c.imaginary << "i" << std::endl;
    }
    else {
        if (c.imaginary > 0) {
            std::cout << c.real << "+" << c.imaginary << "i" << std::endl;
        }
        else if (c.imaginary < 0) {
            std::cout << c.real << c.imaginary << "i" << std::endl;
        }
        else {
            std::cout << c.real << std::endl;
        }
    }
};
```

上述代码中`operator<<()`函数是`complex`类的友元函数，因此它可以访问`complex`类中的数据成员，但它不是`ostream`类的友元函数，并不直接访问`ostream`类的私有成员。所以友元并不是一种双向关系，它只是提供了非成员函数访问类的私有部分。

上述代码不支持语句`std::cout << complex_1 << complex_2`，因为根据`<<`运算符从左往右的结合性，语句`std::cout << complex_1`并没有返回任何一个类型的值，于是向右结合的过程中，语句不符合重载函数的参数类型。如果将该重载函数返回的类型设置为一个`ostream`对象，则可以正常执行有多个`<<`运算符的输出语句：

``` cpp
friend std::ostream& operator<<(std::ostream& os, const complex& c) {
    if (c.real == 0) {
        std::cout << c.imaginary << "i" << std::endl;
        return os;
    }
    else {
        if (c.imaginary > 0) {
            std::cout << c.real << "+" << c.imaginary << "i" << std::endl;
            return os;
        }
        else if (c.imaginary < 0) {
            std::cout << c.real << c.imaginary << "i" << std::endl;
            return os;
        }
        else {
            std::cout << c.real << std::endl;
            return os;
        }
    }
};
```

#### 8.7.2 友元类

将一个类作为另一个类的友元类时，友元类中的所有方法都可以访问原始类的私有成员和保护成员，友元声明需要在原始类中进行，在`private`中还是在`public`中都无关紧要：

``` cpp
class television {
    private:
        friend class remote;
};

class remote {};
```

假设`televison`只需要用到`remote`类私有成员函数`setChannel`，可以只在`television`类声明中将该函数声明为友元，但是必须要使编译器知道`remote`的定义，否则它将不知道`remote`是一个类。但是当我们将`remote`的定义提到`televison`之前时，`remote`里使用到的`televison`对象又将没有定义。**解决这种循环依赖的方法是使用前向声明**：

``` cpp
class televison;

class remote {
    private:
        television TV_LIVINGROOM;
};

class television {
    private:
        friend void remote::setChannel(televison& TV, int channel);
};
```

对于**两个类相互为友元**的情况，如果两个类中的方法都相互使用到了对方对象的成员，则需要将先定义的类的函数定义放在第二个类之后，在类声明中只保留函数原型的声明。这是因为在第一个类中使用到的第二个类对象的详细信息并没有被编译器获取到：

``` cpp
class MyNewFileDialog {
    private:
        friend class MyFrame;
        void OnSelectCover(wxCommandEvent& event);
};

class MyFrame {
    private:
        friend class MyNewFileDialog;

};

inline void MyNewFileDialog::OnSelectCover(wxCommandEvent& event) {}
```

### 8.8 类的自动转换和强制类型转换

对于**只有一个参数**的类的构造函数，C++允许将该参数的类型转换为类对象的类型：

``` cpp
class Account {
    private:
        std::string fullname;
        std::string ID;
        double balance;
    public:
        Account(const std::string& fn);
        Account() {};   // Default Constructor Function
        ~Account() = default;
};

Account::Account(const std::string& fn) : fullname(fn),
                                          ID(GLOBAL_ID),
                                          balance(0.0) {};

int main() {
    Account chicagoBank;
    chicagoBank = std::string("Chicago");
}
```

可以使用关键字`explicit`关闭这种隐式的自动转换，但是仍然允许显式的强制类型转换。对于这种转换需要注意的一点是二步转换只能发生在没有二义性的时候，例如两个构造函数定义了可以从`double`和`long`类型转换为类对象的类型，而需要处理如`classObject = 23`这样的语句，编译器不知道要把`int`类型的转换为`long`还是`double`，这将引发二义性错误。

``` cpp
chicagoBank = Account(std::string("Chicago"));
chicagoBank = (Account)std::string("Chicago");
```

转换函数是用户定义的强制类型转换，可以像使用强制类型转换那样使用它们，转换函数**必须是类方法**，且**不能指定返回类型**，也**不能带有参数**，它们的格式如下：

``` cpp
operator std::string() const;   // In Class Declaration

Account::operator std::string() const {
    return fullname;
}
```

### 8.9 复制类的对象

#### 8.9.1 复制构造函数

当使用一个对象来初始化另一个对象时，编译器将自动生成构造函数，这称为**复制构造函数**，复制构造函数的函数原型如下：

``` cpp
TableTennisPlayer(const TableTennisPlayer&);
// Class_name(const class_name&)
```

新建一个对象并将其初始化为同类现有对象时，复制构造函数将被调用。这在如下情形中会发生：
- 将新对象显式地初始化为现有的对象；

    ``` cpp
    TableTennisPlayer lakeTeam(dakeTeam);
    TableTennisPlayer lakeTeam = dakeTeam;
    TableTennisPlayer lakeTeam = TableTennisPlayer(dakeTeam);
    TableTennisPlayer* lakeTeam = new TableTennisPlayer(dakeTeam);
    // 'dakeTeam' is a TableTennisPlayer object
    ```
- 函数按值传递对象或者函数返回一个对象时，前者将实参复制给了形参，后者将产生一个临时对象，这两个步骤都会调用复制构造函数。

默认的复制构造函数**逐个复制非静态成员**（成员复制又称为浅复制）。可以由程序员提供显式复制构造函数以覆盖原有的默认复制构造函数的行为，这些需要覆盖的行为通常有：
- 如果类中包含静态数据成员，即其值将在新对象被创建时更新，则在显式的复制构造函数中更新静态数据成员的值（在有必要的情况下）；
- 浅复制中有一些复制只是传递指针，例如结构、字符串以及数组等，所以需要使用深度复制的方法解决这一问题，就是将结构、字符串或者数组的值、成员的值传递给新的对象。

``` cpp
struct point {
    double x;
    double y;
};

class SelfDefineString {
    private:
        char* str;
        int len;
        point loc;
        static int strNum;
    public:
        SelfDefineString(const char* s, const point l = {0, 0});
        SelfDefineString(const SelfDefineString& sds);
        SelfDefineString();
        ~SelfDefineString();

        friend std::ostream& operator << (std::ostream& os, 
                                          const SelfDefineString& str);
};

int SelfDefineString::strNum = 0;

SelfDefineString::SelfDefineString(const char* s, const point l) {
    len = std::strlen(s);
    str = new char[len + 1];
    std::strcpy(str, s);
    strNum++;
    loc = l;
    std::cout << "\n";
    std::cout << strNum << ": \"" << str << "\" :\n"
              << "  Created Successfully!   Length: " << len << "\n";
}

SelfDefineString::SelfDefineString(const SelfDefineString& sds) {
    strNum++;
    len = sds.len;
    str = new char[len + 1];
    std::strcpy(str, sds.str);
    loc = sds.loc;
    std::cout << strNum << ": \"" << str << "\" :\n"
              << "  Copied Successfully!    Length: " << len << "\n";
}

SelfDefineString::SelfDefineString() {
    len = 12;
    str = new char[len + 1];
    std::strcpy(str, "Izumi Sagiri");
    strNum++;
    std::cout << "\n";
    std::cout << strNum << ": \"" << str << "\" :\n";
    std::cout << "  Created Defaultedly!    Length: " << len << "\n";
}

SelfDefineString::~SelfDefineString() {
    std::cout << "\n";
    std::cout << "\"" << str << "\" Deleted Successfully!\n";
    strNum--;
    std::cout << "  " << strNum << " Strings Left.";
    delete[] str; 
}

std::ostream& operator << (std::ostream& os, 
                           const SelfDefineString& str) {
    os << str.str << "  (" << str.loc.x << ", " << str.loc.y << ")";
    return os;
}

void callmeByValue(SelfDefineString s) {
    std::cout << s << "\n";
}

int main() {
    SelfDefineString str_1("Shumn");
    SelfDefineString str_2 = "Rteu";
    SelfDefineString str_3("Zzxw", {2, 2});
    callmeByValue(str_3);
    std::cout << str_3;
    return 0;
}
```

重点时是该类的复制构造函数实现了统计字符串个数的`strNum`的自增（否则在传递对象的值后字符串的个数将不正确），并且将对象中的字符串使用`strcpy`函数赋值给新的对象，防止两个对象中的字符串的实际地址是同一个，其中一个对象调用了析构函数后另一个对象对同一个内存两次释放。

#### 8.9.2 赋值运算符

C++允许类对象赋值，这是通过自动为类重载赋值运算符实现的，该运算符的原型如下：

``` cpp
SelfDefineString& operator = (const SelfDefineString& sds);
// class_name& operator = (const class_name&);
// class_name& class_name::operator = (const class_name&) {}
```

与复制构造函数类似，赋值运算符也是通过逐个复制对象成员构造新的对象的（静态成员不受影响），这种浅复制也会引发问题，而解决这些问题的方法是：
- 由于复制的目标对象可能引用了以前分配的数据，所以函数应当使用`delete[]`来释放这些数据；
- 函数应当避免将对象赋给自身，否则给对象重新赋值前，释放内存操作可能删除对象的内容；
- 函数返回一个指向调用对象的引用。

``` cpp
SelfDefineString& SelfDefineString::operator = (const SelfDefineString& sds) {
    if (this == &sds)
        return *this;
    delete [] str;
    len = sds.len;
    str = new char [len + 1];
    std::strcpy(str, sds.str);
    return *this;
}
```

通过返回一个对象，函数可以像常规赋值操作进行连续赋值。对于类中成员有其他类对象的情况，若该对象所属的类定义了自己的复制构造函数以及重载赋值运算符，那么不需要为该对象重新定义复制构造函数或者重载赋值运算符，因为逐一复制**具有一定的智能性，能够使用成员类型定义的复制构造函数以及重载赋值运算符**。

## 9 类的继承

### 9.1 公有继承

从一个类派生出另一个类时，原始类称为**基类**，继承类称为**派生类**。派生时需要使用冒号指出该类派生自哪个类：

``` cpp
class MyFrame : public wxFrame {
    // Other code
};
```

使用关键字`public`指出类`wxFrame`是一个公有基类，而`MyFrame`通过**公有派生**从基类中派生出，使用公有派生，基类的公有成员将成为派生类的公有成员，基类的私有成员也将成为派生类的一部分，但只能通过基类的公有和保护方法访问。

``` cpp
#include <iostream>
#include <string>

class TableTennisPlayer {
    private:
        std::string firstname;
        std::string lastname;
        bool hasTable;
    public:
        TableTennisPlayer(const std::string& fn = "None",
                          const std::string& ln = "None",
                          bool ht = false);
        ~TableTennisPlayer() = default;
        void getName() const;
        bool getHasTabel() const { return hasTable; };
        void resetHasTabel(bool h) { hasTable = h; };
};

TableTennisPlayer::TableTennisPlayer(const std::string& fn,
                                     const std::string& ln,
                                     bool ht) : 
                                     firstname(fn),
                                     lastname(ln),
                                     hasTable(ht) {}
                                    
void TableTennisPlayer::getName() const {
    std::cout << lastname << ", " << firstname << std::endl;
}

class RatedPlayer : public TableTennisPlayer {
    private:
        unsigned int rating;
    public:
        RatedPlayer(unsigned int r = 0,
                    const std::string& fn = "None",
                    const std::string& ln = "None",
                    bool ht = false);
        ~RatedPlayer() = default;
        unsigned int getRating() const { return rating; }
        void resetRating(unsigned int r) { rating = r; }
};

RatedPlayer::RatedPlayer(unsigned int r,
                         const std::string& fn,
                         const std::string& ln,
                         bool ht) : 
                         TableTennisPlayer(fn, ln, ht), 
                         rating(r) {}
```

可以看出`RatedPlayer`构造函数无法访问派生得到的私有成员，而需要通过基类的构造函数访问私有成员。创建派生类对象时，程序首先调用基类构造函数，然后再调用派生类构造函数，基类构造函数负责初始化继承的数据成员，派生类构造函数将初始化新增的数据成员，可以使用**初始化器列表指明要使用的基类构造函数**。派生类对象过期后，程序将先调用派生类析构函数，再调用基类析构函数。派生类构造函数可以使用初始化列器列表机制将值传递给基类构造函数。其余的成员函数则不能像构造函数一样通过列表方法访问基类的数据，只能通过基类的公有和保护方法。

派生类对象可以使用基类的公有方法。基类指针可以在不进行显式类型转换的情况下指向派生类对象，基类引用可以在不进行显式类型转换的情况下引用派生类对象（然而这种关系只是单向的，派生类的指针和引用不能转换为基类对象）：

``` cpp
RatedPlayer lakePlayer(11, "Wary", "Duke", true);
TableTennisPlayer* pt = &lakePlayer;
TableTennisPlayer& rt = lakePlayer;

pt->Name();
rt.Name();
```

公有继承是一种`is-a`（是一种）关系，这称为`is-a`继承。

### 9.2 多态公有继承与虚函数

**多态公有继承**指同一种方法在派生类和基类中的行为是不一样的，方法的行为应取决于调用该方法的对象，同一个方法的行为随上下文而定。使用多态公有继承需要使用`virtual`虚函数，使用`virtual`时程序将根据引用或指针指向的对象类型来选择匹配的方法，而不是根据参数：

``` cpp
class Brass {
    private:
        std::string fullName;
        long account;
        double balance;
    public:
        Brass(const std::string& s = "Nullbody", 
              long ac = -1,
              double bal = 0.0);
        void Deposit(double de);
        virtual void Withdraw(double wi);
        double ShowBalance() const;
        virtual void ShowAccount() const;
        virtual ~Balance() {}
};

class BrassPlus : public Brass {
    private:
        double maxLoan;
        double rate;
        double owesBank;
    public:
        BrassPlus(const std::string& s = "Nullbody",
                  long ac = -1,
                  double bal = 0.0,
                  double ml = 500,
                  double r = 0.1125);
        BrassPlus(const std::string& s = "Nullbody", 
                  long ac = -1,
                  double bal = 0.0);
        virtual void Withdraw(double wi);
        virtual void ShowAccount() const;
        void ResetMaxLoan(double m) { maxLoan = m; }
        void ResetRate(double r) { rate = r; }
        void ResetOwes(double o) { owesBank = o; }
};
```

以上代码使用了虚析构函数，其目的是确保按照正确的顺序调用派生类和基类的析构函数。当派生类具有一个执行其他功能的析构函数，基类必须定义一个虚析构函数。在通常情况下，**一般都会给基类定义一个虚析构函数**。

虚函数有以下几条注意点：
- 构造函数不能是虚函数，因为派生类不继承基类的构造函数，所以将类构造函数声明为虚函数没有意义；
- 即使基类不需要显式析构函数提供服务，也不应该依赖于默认析构函数，而应该提供虚析构函数，即使它不执行任何操作；

    ``` cpp
    virtual ~BaseClass() {}
    ```

- 友元函数不能是虚函数，因为友元函数并不是类的成员，只有成员函数才能是虚的，同样友元函数不能被派生类继承；
- 如果派生类没有重新定义虚函数，将使用该函数的基类版本。如果派生类位于派生链当中，则将使用最新的虚函数版本；
- 派生类的重新定义并不会生成虚函数的两个版本，不存在虚函数的重载，而是将基类的虚函数隐藏了。
  - 如果重新定义继承的方法，应确保与基类的虚函数的原型完全相同，但如果返回类型是基类引用或者指针，则可以修改为派生类引用或者指针，这种语法称为**返回类型协变**。
  - 如果基类中的虚函数有重载版本，则在派生类中应当重新定义所有的重载版本。
    
    ``` cpp
    class BaseClass {
        public:
            virtual void ShowPerks(int a) const;
            virtual void ShowPerks(double x) const;
            virtual void ShowPerks() const;
    };

    class DerivedClass : public BaseClass {
        public:
            virtual void ShowPerks(int a) const;
            virtual void ShowPerks(double x) const;
            virtual void ShowPerks() const;
    };
    ```

在基类和派生类的关系中，出现了一种新的访问控制关键字：`protetced`。在类外不能使用`protected`的变量和函数，对类外相当于`private`；对于派生类则可以使用`protected`中的变量和函数，相当于`public`。一般来说，**最好对类数据成员采用私有访问控制，不要使用保护访问控制**，派生类通过基类公有方法访问基类的数据成员。

C/C++编译器将源代码中的函数调用解释为执行特定的函数代码块，这个过程被称为**函数名联编**。编译器在编译过程中的函数名联编被称为**静态联编**或者**早期联编**；由于使用哪一个函数时不确定的行为编译器生成能够在程序运行期间选择正确的函数的代码，这一过程称为**动态联编**或者**晚期联编**。虚函数的联编就属于动态联编。

虚函数的工作原理大致是这样的：编译器处理虚函数时，给每一个对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，指向的这个数组称为**虚函数表**。基类与派生类对象都有属于自己的虚函数表：基类的虚函数表保存了基类中定义的所有虚函数的地址，派生类的虚函数表基于基类虚函数表，有以下三种变化：
- 当基类中的虚函数没有在派生类中重新定义时，派生类的虚函数表存储的对应虚函数地址不发生变化；
- 当基类中的虚函数在派生类中重新定义时，派生类的虚函数表存储的对应虚函数地址变为重新定义的函数的地址；
- 当派生类中有新增的虚函数时，派生类的虚函数表新增这个虚函数的地址。

由于虚函数的工作原理，虚函数在内存和执行速度方面都有一定的成本。

### 9.3 抽象基类与纯虚函数

抽象基类是指含有为纯虚函数的的基类，它不能用于创建对象。纯虚函数可以用于提供未实现的函数，它在类中可以不被定义而只有函数原型，从抽象基类中派生出的类可以有自己的继承自抽象基类的纯虚函数的定义。纯虚函数定义如下，其原型的结尾用`= 0`表示：

``` cpp
const double PI = 3.14159265;
class BaseEllipse {
    private:
        double x;
        double y;
    public:
        virtual double Area() const = 0; 
};

class Ellipse : public BaseEllipse {
    private:
        double majorAxis;
        double minorAxis;
    public:
        virtual double Area() const;
};

class Circle : public BaseEllipse {
    private:
        double radius;
    public:
        virtual double Area() const;
};

double Ellipse::Area() const {
    return PI * majorAxis * minorAxis;
}

double Circle::Area() const {
    return PI * raidus * radius;
}
```

C++允许抽象基类中的纯虚函数具有具体的实现，方法是省略`virtual`关键字，这样做派生类能够继承省略了`virtual`关键字的纯虚函数：

``` cpp
class BaseEllipse {
    public:
        void Move(int nx, int ny) = 0;
};

void BaseEllipse::Move(int vecx, int vecy) {
    x += vecx;
    y += vecy;
}
```

### 9.4 私有继承与保护继承

使用私有继承时，基类的公有成员和保护成员都将成为派生类的私有成员，基类方法不会成为派生对象公有接口的一部分，但可以在派生类的成员函数中使用它们。可以使用`private`关键字进行私有继承：

``` cpp
class Student : private std::string, private std::valarray<double>
```

私有继承将对象作为一个未被命名的继承对象添加到派生类中，我们使用**子对象**表示这种通过继承或包含添加的对象。隐式地继承组件而不是成员对象将影响派生类构造函数通过基类构造函数访问变量的列表初始化代码，必须通过基类名而不是成员名标识构造函数：

``` cpp
Student(const std::string& s, const DoubleArray& da) :
        std::string(s),
        DoubleArray(da) {};
```

必须使用基类名和作用域解析运算符来调用基类的方法：

``` cpp
double Student::Average() const {
    if (DoubleArray::size() > 0)
        return DoubleArray::sum() / DoubleArray::size();
    else
        return 0;
}
```

必须使用强制类型转换访问隐式的基类对象（使用强制类型转换将派生类的对象转换为派生类从基类私有继承来的不具有名称的那个子对象）。x

``` cpp
const std::string& Student::Name() const {
    return (const std::string&) *this;
}

// Friend function
std::ostream& operator << (std::ostream& os, const Student& stu) {
    os << "Scores for " << (const std::string&) stu << ":\n";
    stu.arrayOutput(os);
    return os;
}
```

保护继承是私有继承的变体，它将基类的保护成员和公有成员继承到派生类的保护成员中，在列出基类时使用关键字`protected`：

``` cpp
class Student : protected std::string, protected std::valarray<double>
```

|特征|公有继承|保护继承|私有继承|
|:---:|:---:|:---:|:---:|
|公有成员->|派生类的公有成员|派生类的保护成员|派生类的私有成员|
|保护成员->|派生类的保护成员|派生类的保护成员|派生类的私有成员|
|私有成员->|只能通过基类接口访问|只能通过基类接口访问|只能通过基类接口访问|
|能否隐式向上转换|是|是（但只能在派生类中）|否|

隐式向上转换意味着无需进行显式类型转换，就可以将基类指针或者引用指向派生类的对象。

可以有两种方法使得在保护继承和私有继承中基类的方法可以在派生类外使用，可以有以下两种方法：
- 在派生类中定义一个使用基类方法的派生类方法：

    ``` cpp
    double Student::sum() const {
        return std::valarray<double>::sum();
    }
    ```

- 将函数调用包装到另一个函数中，使用`using`声明指出派生类可以使用特定的基类成员。例如如果希望`Student`类能够使用`valarray`类的一些方法，就需要像下面这样：

    ``` cpp
    class Student : private std::string, private std::valarray<double> {
        public:
            using std::valarray<double>::min;
            using std::valarray<double>::max;
    }
    ```
