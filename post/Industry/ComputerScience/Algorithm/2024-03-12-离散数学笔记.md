---
title: 离散数学笔记
author: AshGrey
date: 2024-03-12 00:00:00 +0800
categories: [Computer Science, Algorithm]
tags: [Computer Science, Algorithm, Discrete Mathematics]
math: true
---

> 本文章所属领域：
>
> [实践产业知识 - 工业产业 - 计算机科学 - 算法]({% post_url /Computer Science/2024-02-08-计算机科学：索引笔记 %})
{: .prompt-info}
>
> 注意这篇笔记内的所有程序都不具有较好的参考性，因为都是我还没学习算法时写下的

<br>

## 1 逻辑和证明

<br>

### 1.1 命题逻辑

<br>

命题（propositions）是一个称述语句，它或真或假，但不可能既真又假。

<br>

> **定义 1.1-1 否定（negation）**
>
> 令 $p$ 为一命题，则 $p$ 的否定记作 $\lnot p$ 或者 $\bar{p}$，指「不是 $p$ 所指的情形」，$p$ 的真值与 $\lnot p$ 相反

<br>

> **定义 1.1-2 合取（conjunction）**
>
> 令 $p$ 和 $q$ 为命题，则 $p$ 和 $q$ 的合取即命题「$p$ 并且 $q$」，记作 $p\wedge q$，当 $p$ 和 $q$ 都是真时，$p\wedge q$ 为真，否则为假

<br>

> **定义 1.1-3 析取（disjunction）**
>
> 令 $p$ 和 $q$ 为命题，则 $p$ 和 $q$ 的析取即命题「$p$ 或者 $q$」，记作 $p\vee q$，当 $p$ 和 $q$ 都是假时，$p\vee q$ 为假，否则为真

<br>

> **定义 1.1-4 异或（exclusive）**
>
> 令 $p$ 和 $q$ 为命题，则 $p$ 和 $q$ 的异或即命题「当 $p$ 和 $q$ 中恰好只有一个为真时命题为真，否则为假」，记作 $p\oplus q$

<br>

异或 $p\oplus q$ 实际可以表述为 $(p\wedge\lnot q)\vee(\lnot p\wedge q)$，这意味着异或并不是逻辑的基本运算。也有的人将异或记为 $\overline{\vee}$，不过我不是很喜欢这个记号。此外还有**与非**和**或非**两种非基本运算，前者可以记作 $\uparrow$，后者可以记作 $\downarrow$。

<br>

> **定义 1.1-5 条件语句（conditional statement）**
>
> 令 $p$ 和 $q$ 为命题，条件语句 $p\rightarrow q$ 是命题「如果 $p$，则 $q$」。当 $p$ 为真而 $q$ 为假时，条件语句 $p\rightarrow q$ 为假，否则为真（当 $p$ 为假时是无意义的真）。命题 $p$ 被称为假设（hypothesis）或前件（antecedent）或前提（premise），命题 $q$ 被称为结论（conclusion）或后件（consequence）

<br>

条件语句有时候又被称为蕴含（implication）。条件语句的自然语言表达相当多，在中文语境中基本表述为「如果···那么···」。由条件语句可以构造出一些新的条件语句，例如：
- $q\rightarrow p$ 称为 $p\rightarrow q$ 的**逆命题**（converse）；
- $\lnot p\rightarrow\lnot q$ 称为 $p\rightarrow q$ 的**否命题**（inverse）；
- $\lnot q\rightarrow\lnot p$ 称为 $p\rightarrow q$ 的**逆否命题**（contrapositive）。

当两个复合命题总是具有相同的真值时，无论其命题变量的真值是什么，我们称它们是等价的（equivalent）。根据真值表，条件语句 $p\rightarrow q$ 与其逆否命题 $\lnot q\rightarrow\lnot p$ 是等价的，其逆命题 $q\rightarrow p$ 和 否命题 $\lnot p\rightarrow\lnot q$ 是等价的。

<br>

> **定义 1.1-6 双条件语句（biconditional statement）**
>
> 令 $p$ 和 $q$ 为命题，双条件语句 $p\leftrightarrow q$ 是命题「$p$ 当且仅当 $q$」，当 $p$ 和 $q$ 有同样的真值时，双条件语句 $p\leftrightarrow q$ 为真，否则为假。双条件语句又被称为双向蕴含（bi-implication）

<br>

双条件语句又可以使用缩写符号 $\text{iff}$ 或者复合语句 $(p\rightarrow q)\wedge(q\rightarrow p)$ 表示。

<br>

可以规定逻辑运算符的顺序，使得之后的复合语句不需要使用大量的括号：
- 1级：否定 $\lnot$
- 2级：合取 $\wedge$
- 3级：析取 $\vee$，一般仍然使用括号区分合取和析取的作用顺序
- 4级：蕴含 $\rightarrow$
- 5级：双向蕴含 $\leftrightarrow$，一般仍然使用括号区分蕴含和双向蕴含的作用顺序

<br>

> **定义 1.1-7 合式公式（well formed formulas）**
>
> - 单个命题变项是合式公式，并被称为**原子命题公式**；
> - 若 $p$ 是合式公式，则 $\lnot p$ 也是合式公式；
> - 若 $p,q$ 都是合式公式，则 $p\wedge q$、$p\vee q$、$p\to q$ 以及 $p\leftrightarrow q$ 都是合式公式；
> - 只有有限次地应用上述三个定义形成的符号串才是合式公式

<br>

> **定义 1.1-8 波兰表达式**
>
> 一般而言，使用运算符构成公式有三种方式（设以下 $p,q$ 均为合式公式）：
> - **中缀式**：逻辑运算符放在中间，如 $p\vee q$；
> - **前缀式**：逻辑运算符放在前面，如 $\vee pq$；
> - **后缀式**：逻辑运算符放在后面，如 $pq\vee$；
>
> 所谓的波兰表达式就是波兰逻辑学家 J.Lukasiewicz 提出的中缀改前缀的变换方法，例如对于人类能正常阅读的逻辑公式 $p\vee((q\wedge r)\vee s)$ 改写成 $\vee p\vee\wedge qrs$，这样对于计算机来说就不用使用扫描括号以确定顺序。所谓的逆波兰表达式则是中缀变后缀。

<br>

### 1.2 命题等价式

<br>

> **定义 1.2-1 永真式（tautology）**
>
> 一个无论命题变量的值为多少，真值永远是真的复合命题被称为永真式或者重言式（tautology）。一个真值永远是假的复合命题被称为矛盾式（contradiction）。既不是永真式也不是矛盾式的复合命题被称为可能式（contingency）

<br>

> **定义 1.2-2 逻辑等价（logically equivant）**
>
> 如果 $p\leftrightarrow q$ 是永真式，则复合命题 $p$ 和 $q$ 称为逻辑等价的。用记号 $p\equiv q$ 或者 $p\Leftrightarrow q$ 表示逻辑等价

<br>

判断两个复合命题是否是逻辑等价的可以使用真值表（对于命题变量较少的复合命题来说简单，命题变量较多时，应该通过简单的情形推广到一般情形）进行判断，使用这个方法，可以给出以下逻辑等价式子：

<br>

|逻辑等价式|名称|
|:---:|:---:|
|$p\wedge\mathsf{T}\Leftrightarrow p$，$p\vee\mathsf{F}\Leftrightarrow p$|恒等律（Identity）|
|$p\vee\mathsf{T}\Leftrightarrow\mathsf{T}$，$p\wedge\mathsf{F}\Leftrightarrow\mathsf{F}$|支配律（Domination）|
|$p\vee p\Leftrightarrow p$，$p\wedge p\Leftrightarrow p$|幂等律（Idempotent）|
|$\lnot(\lnot p)\Leftrightarrow p$|双重否定律（Double Negation）|
|$p\vee q\Leftrightarrow q\vee p$，$p\wedge q\Leftrightarrow q\wedge p$|交换律（Commutative）|
|$(p\vee q)\vee r\Leftrightarrow p\vee(q\vee r)$，$p\wedge(q\wedge r)\Leftrightarrow(p\wedge q)\wedge r$|结合律（Associative）|
|$p\vee(q\wedge r)\Leftrightarrow(p\vee q)\wedge(p\vee r)$，$p\wedge(q\vee r)\Leftrightarrow(p\wedge q)\vee(p\wedge r)$|分配律（Distributive）|
|$\lnot(p\wedge q)\Leftrightarrow\lnot p\vee\lnot q$，$\lnot(p\vee q)\Leftrightarrow\lnot p\wedge\lnot q$|德·摩根律（De Morgan）|
|$p\vee(p\wedge q)\Leftrightarrow p$，$p\wedge(p\vee q)\Leftrightarrow p$|吸收律（Absorption）|
|$p\vee\lnot p\Leftrightarrow\mathsf{T}$，$p\wedge\lnot p\Leftrightarrow\mathsf{F}$|否定律（Negation）|

<br>

以上都是否定、析取和合取的逻辑等价表达式，还可以给出蕴含和双向蕴含的逻辑等价表达式：

$$
    \begin{aligned}
        p\rightarrow q&\Leftrightarrow\lnot p\vee q\\
        p\rightarrow q&\Leftrightarrow\lnot q\rightarrow\lnot p\\
        p\vee q&\Leftrightarrow\lnot p\rightarrow q\\
        p\wedge q&\Leftrightarrow\lnot(p\rightarrow\lnot q)\\
        \lnot(p\rightarrow q)&\Leftrightarrow p\wedge\lnot q\\
        (p\rightarrow q)\wedge(p\rightarrow r)&\Leftrightarrow p\rightarrow(q\wedge r)\\
        (p\rightarrow r)\wedge(q\rightarrow r)&\Leftrightarrow(p\vee q)\rightarrow r\\
        (p\rightarrow q)\vee(p\rightarrow r)&\Leftrightarrow p\rightarrow (q\vee r)\\
        (p\rightarrow r)\vee(p\rightarrow r)&\Leftrightarrow(p\wedge q)\rightarrow r\\
        p\leftrightarrow q&\Leftrightarrow(p\rightarrow q)\wedge(q\rightarrow p)\\
        p\leftrightarrow q&\Leftrightarrow\lnot q\leftrightarrow\lnot p\\
        p\leftrightarrow q&\Leftrightarrow(p\wedge q)\vee(\lnot p\wedge\lnot q)\\
        \lnot(p\leftrightarrow q)&\Leftrightarrow p\leftrightarrow\lnot q\\
        p\rightarrow (q\rightarrow r)&\Leftrightarrow (p\wedge q)\rightarrow r
    \end{aligned}
$$

<br>

因为上述逻辑等价式最多只涉及三个命题变量，真值表并不复杂。当涉及非常多的命题变量时再使用真值表就过于麻烦了。用 $\bigvee_{j=1}^{n}p_j$ 表示 $p_1\vee \cdots\vee p_n$，用 $\bigwedge_{j=1}^n p_j$ 表示 $p_1\wedge\cdots\wedge p_n$。则一般情形的 De Morgan 律可以表述为：

$$
    \lnot\left(\bigvee_{j=1}^np_j\right)\Leftrightarrow\bigwedge_{j=1}^n\lnot p_j,\quad\lnot\left(\bigwedge_{j=1}^np_j\right)\Leftrightarrow\bigvee_{j=1}^n\lnot p_j
$$

<br>

利用命题等价式可以分析（不是解决）许多有趣的问题：

<br>

> **问题1 $n$ 皇后问题**
>
> $n$ 皇后问题要求在一个 $n\times n$ 的棋盘上放置 $n$ 个皇后，目的是使皇后之间不能相互吃掉，这意味着没有两个皇后被放置在同一行、同一列或者同一对角线上

<br>

引入 $n^2$ 个变量 $p(i,j),1\leq i,j\leq n$，其含义如下：当在第 $i$ 行第 $j$ 列的格子上有皇后时，$p(i,j)$ 为真，否则为假。我们先断言每一行都只能有一个皇后，这可以通过说明每一行至少有一个皇后和每一行最多只有一个皇后来完成。

注意到 $\bigvee_{j=1}^np(i,j)$ 断言第 $i$ 行至少有一个皇后，于是每一行都至少有一个皇后可以由以下逻辑表达式断言：

$$
    Q_1=\bigwedge_{i=1}^n\bigvee_{j=1}^np(i,j)
$$

对于每一行最多包含一个皇后，则当整数 $k,j$ 满足 $1\leq j<k\leq n$ 时必须有 $p(i,j)$ 和 $p(i,k)$ 不同时为真，用逻辑表达式表述就是 $\lnot p(i,j)\vee\lnot p(i,k)$。于是检测每一行最多只有一个皇后可以由以下逻辑表达式断言：

$$
    Q_2=\bigwedge_{i=1}^n\bigwedge_{j=1}^{n-1}\bigwedge_{k=i+1}^n\lnot p(i,j)\vee\lnot p(i,k)
$$

保证每一列都最多只有一个皇后的断言如下：

$$
    Q_3=\bigwedge_{j=1}^n\bigwedge_{i=1}^{n-1}\bigwedge_{k=j+1}^n\lnot p(i,j)\vee\lnot p(k,j)
$$

注意到如果有 $i+i'=j+j'$ 或者 $i-i'=j-j'$ 成立，则说明 $(i,j)$ 和 $(i',j')$ 格子在对角线上，根据这个命题可以知道对角线上不得有多个皇后可以由以下逻辑表达式断言：

$$
    \begin{aligned}
    Q_4&=\bigwedge_{i=2}^n\bigwedge_{j=1}^{n-1}\bigwedge_{k=1}^{\min(i-1, n-j)}\lnot p(i,j)\vee\lnot p(i-k, k+j)\\
    Q_5&=\bigwedge_{i=1}^{n-1}\bigwedge_{j=1}^{n-1}\bigwedge_{k=1}^{\min(n-i,n-j)}\lnot p(i,j)\vee\lnot p(i+k,j+k)
    \end{aligned}
$$

对于 $n$ 皇后问题，这实际上就是要找到所有使得 $\bigwedge_{i=1}^5 Q_i$ 为真的 $p(i,j)$。但是以上步骤只是在分析问题，具体的解法需要借助其余知识。

<br>

> **问题2 数独**
>
> 数独可表示为一个 $9\times 9$ 格，它由 $9$ 个称为九宫格的 $3\times 3$ 子格组成。$81$ 个单元中的一部分被赋予 $1,\cdots,9$ 中的数字之一，称为已知单元。数独的目的是找出其余空着的未知单元应当填的数字，使得每一行、每一列、每个小九宫格都包含九个不同的数字。数独也可以推广到 $n^2\times n^2$ 格，由 $n^2$ 个 $n\times n$ 的子格组成

<br>

令 $p(i,j,n)$ 表示一个命题，当数 $n$ 位于第 $i$ 行和第 $j$ 列的单元时为真，一共有 $729$ 个这样的命题。数独的要求如下：
- 对于已知单元，当第 $i$ 行和第 $j$ 列的单元中是已知数 $n$ 时，断言 $Q_1=\bigwedge_{i,j,n} p(i,j,n)$；
- 每一行都包含了每一个数，断言

    $$
        Q_2=\bigwedge_{i=1}^9\bigwedge_{n=1}^9\bigvee_{j=1}^9p(i,j,n)
    $$

- 每一列都包含了每一个数，断言

    $$
        Q_3=\bigwedge_{j=1}^9\bigwedge_{n=1}^9\bigvee_{i=1}^9p(i,j,n)
    $$

- 每一个子格包含了每一个数，断言

    $$
        Q_4=\bigwedge_{r=0}^2\bigwedge_{s=0}^2\bigwedge_{n=1}^9\bigvee_{i=1}^3\bigvee_{j=1}^3p(3r+i,3s+j,n)
    $$

对于数独问题，实际上就是要找到所有使得 $\bigwedge_{i=1}^4Q_i$ 为真的 $p(i,j,n)$ 变量。

<br>

### 1.3 谓词和量词

<br>

> **定义 1.3-1 谓词（predicate）**
>
> 一般地，涉及 $n$ 个变量 $x_1,\cdots x_n$ 的语句可以表示成
> 
> $$
>   P(x_1,\cdots, x_n)
>   $$
>
> 形式为 $P(x_1,\cdots,x_n)$ 的语句是命题函数 $P$ 在 $n$ 元组 $(x_1,\cdots,x_n)$ 的值，$P$ 也称为 $n$ 位谓词或 $n$ 元谓词

<br>

当命题函数中的变量均被赋值时，所得到的语句变为某个具有真值的命题。量化表示在何种程度上谓词对于一定范围的个体成立：全称量化，一个谓词在所考虑范围内对每一个个体都为真；存在量化，一个谓词对所考虑范围内的一个或多个个体为真。
- 全称量词：命题为某一性质对于变量在某一特定域内的所有值均为真，这一特定领域称为变量的**论域**（domain of discource）或**全体域**（universe of discource）。

    > **定义 1.3-2 全称量化（universal quantification）**
    > 
    > $P(x)$ 的全称量化是命题「$P(x)$ 对 $x$ 在其论域的所有值为真」，符号表示为 $\forall xP(x)$，其中 $\forall$ 称为全称量词。一个使 $\forall xP(x)$ 为假的 $x$ 称为反例

- 存在量词：命题为某一性质对于变量在其某一特定域内至少一个值为真。

    > **定义 1.3-3 存在量化（existential quantification）**
    > 
    > $P(x)$ 的存在量化是命题「论域中存在一个个体 $x$ 满足 $P(x)$」，符号表示为 $\exists xP(x)$，其中 $\exists$ 称为存在量词

- 唯一性量词：符号表示为 $\exists_1$ 或者 $\exists!$，$\exists_1 xP(x)$ 和 $\exists!xP(x)$ 表示法是指「存在唯一的 $x$ 使得 $P(x)$ 为真」。

<br>

当一个量词的论域是有限的时候，即所有元素可以一一列出时，量化语句就可以用命题逻辑来表达。当论域中的元素为 $x_1,\cdots,x_n$，全称量化 $\forall xP(x)$ 与合取式 $\bigwedge_{i=1}^nP(x_i)$ 等价。

<br>

> **定义 1.3-4 涉及量词的逻辑等价式**
>
> 涉及谓词和量词的语句是逻辑等价的当且仅当无论用什么谓词代入这些语句，也无论为这些命题函数里的变量指定什么论域，它们都具有相同的真值。用 $S\Leftrightarrow T$ 表示涉及谓词和量词的两个语句 $S$ 和 $T$ 是逻辑等价的

<br>

经常需要对量化表达式进行否定，量词的否定规则又称为量词的 De Morgan 律：

$$
    \begin{aligned}
        \lnot\exists xP(x)&\Leftrightarrow\forall x\lnot P(x)\\
        \lnot\forall xP(x)&\Leftrightarrow\exists x\lnot P(x)
    \end{aligned}
$$

<br>

当一个量词出现在另一个量词的论域中时，称其为嵌套量词，例如语句 $\forall x\forall y\forall z(x+(y+z)=(x+y)+z)$。理解这种含有嵌套量词的方法是将其视作嵌套的循环，例如刚才的语句可以理解为一个三重的嵌套循环，分别对 $x,y,x$ 进行了遍历（当然对于论域中的元素是无限的情况，不能做到真正的遍历）。

<br>

### 1.4 推理与证明方法

<br>

> **定义 1.4-1 论证（argument）**
>
> 命题逻辑中的一个论证是一连串的命题，论证的最后一个命题称为结论，其余命题都称为前提。一个论证是有效的，如果它的所有结论为真蕴含着结论为真。
>
> 命题逻辑中的一个论证形式是一连串涉及命题变量的复合命题，无论用说明特定命题来替换其中的命题变量，如果前提均真是结论为真，则称该论证形式是有效的：当 $\bigwedge_{i=1}^np_i\rightarrow q$ 为永真式时，带有前提 $p_1,\cdots,p_n$ 以及结论 $q$ 的论证形式就是有效的

<br>

根据有效的论证形式的定义，从一些永真式里可以推导出有效论证形式：

<br>

|永真式|有效的论证形式|名称|
|:---:|:---:|:---:|
|$(p\wedge(p\rightarrow q)\rightarrow q)$|$(p,p\rightarrow q)\Rightarrow q$|假言推理|
|$(\lnot q\wedge(p\rightarrow q))\rightarrow\lnot p$|$(\lnot q,p\rightarrow q)\Rightarrow\lnot p$|取拒式|
|$(p\rightarrow q)\wedge(q\rightarrow r)\rightarrow r$|$(p\rightarrow q,q\rightarrow r)\Rightarrow (p\rightarrow r)$|假言三段论|
|$((p\vee q)\wedge\lnot p)\rightarrow q$|$(p\vee q,\lnot p)\Rightarrow q$|析取三段论|
|$p\rightarrow p\vee q$|$(p)\Rightarrow p\vee q$|附加律|
|$(p\wedge q)\rightarrow p$|$(p\wedge q)\Rightarrow p$|化简律|
|$((p)\wedge (q))\rightarrow p\wedge q$|$(p,q)\Rightarrow p\wedge q$|合取律|
|$((p\vee q)\wedge(\lnot p\vee r))\rightarrow(q\vee r)$|$(p\vee q,\lnot p\vee r)\Rightarrow q\vee r$|消解律|

<br>

含有量词的命题函数是我们关心的，以下有四个有关量词的有效论证形式：
- **全称实例**是从给定前提 $\forall xP(x)$ 得出 $P(c)$ 为真的推理规则，其中 $c$ 是论域里的一个成员；
- **全称引入**是从对论域里所有元素 $c$ 都有 $P(c)$ 为真的前提推出 $\forall xP(x)$ 的推理规则，这里所选择的元素 $c$ 必须是论域中任意的一个元素；
- **存在实例**是指如果我们知道 $\exists xP(x)$ 为真，得出在论域中存在一个元素 $c$ 使得 $P(c)$ 为真的推理规则；
- **存在引入**是由已知有一特定的 $c$ 使得 $P(c)$ 为真时得出 $\exists xP(x)$ 为真的推理规则。

<br>

#### 1.4.1 直接证明法

<br>

直接证明法是通过证明如果 $p$ 为真，那么 $q$ 也一定为真，这样 $p$ 为真而 $q$ 为假的情况就不会发生，从而说明了 $p\rightarrow q$ 为真，以下就是一个直接证明法的例子：

<br>

> **问题 1**
>
> 给出命题「如果 $n$ 是奇数，则 $n^2$ 是奇数」的直接证明

<br>

证明：当 $n$ 是奇数时，可以得到 $n=2k+1,k\in\mathbb{Z}$，此时 $n^2=(2k+1)^2=4k^2+4k+1=2(2k^2+2k)+1$，注意到其中 $2k^2+2k\in\mathbb{Z}$，因此 $n^2$ 也是一个奇数。根据全称引入的推理规则，可以得到命题成立（论域是正整数集）。

<br>

#### 1.4.2 反证法

<br>

反证法利用这样一个事实：$p\rightarrow q\Leftrightarrow\lnot q\rightarrow\lnot p$，这意味着条件语句 $p\rightarrow q$ 的证明可以通过其逆否命题 $\lnot q\rightarrow\lnot p$ 进行证明。用反证法时，我们将 $\lnot q$ 作为前提，证明 $\lnot p$ 必须成立，以下就是一个反证法的例子：

<br>

> **问题 2**
>
> 给出命题「如果 $n$ 是整数且 $n^2$ 是奇数，则 $n$ 是奇数」的反证证明

<br>

证明：由于直接证明法不能给出有效的论证形式，考虑反证法。设 $n$ 为偶数，则可以得到 $n=2k,k\in\mathbb{Z}$，此时 $n^2=4k^2=2(2k^2)$，其中 $2k^2$ 是整数，因此 $n^2$ 也是偶数。根据反证法可知命题成立。

<br>

#### 1.4.3 归谬证明法

<br>

要证明命题 $p$ 是真的，假定我们能找到一个矛盾式 $q$ 使得 $\lnot p\rightarrow q$ 为真。因为 $q$ 是假的，所以 $\lnot p$ 是假的，因此可以得到 $p$ 是真的。我们已经知道对于任意命题 $r$，复合命题 $r\wedge\lnot r$ 是矛盾式，所以如果能够证明存在某个命题 $r$ 使得 $\lnot p\rightarrow r\wedge\lnot r$ 为真，就能够证明 $p$ 为真了，这种证明方法被称为归谬证明法。以下就是一个归谬证明法的例子：

<br>

> **问题 3**
>
> 通过归谬证明法来证明 $\sqrt{2}$ 是无理数

<br>

证明：设命题 $p$ 是「$\sqrt{2}$ 是无理数」，假定 $\lnot p$ 为真，即意味着 $\sqrt{2}$ 是有理数，存在整数 $a,b$ 满足 $\displaystyle\sqrt{2}=\frac{a}{b}$，其中 $b\neq 0$ 并且 $a,b$ 没有公因数（此处用到了有理数都能写成既约分数的事实），于是

$$
    2=\frac{a^2}{b^2}\Leftrightarrow 2b^2=a^2
$$

注意到 $2b^2$ 是偶数，这意味着 $a^2$ 和 $a$ 都是偶数，此时 $a=2k,k\in\mathbb{Z}$，于是可以得到 $b^2=2k^2$，用相同的方法可以推出 $b^2$ 和 $b$ 都是偶数。这与 $a,b$ 没有公因数这一前提矛盾，根据归谬证明法可以得出 $\sqrt{2}$ 是无理数。

<br>

#### 1.4.4 存在性证明

<br>

有一些定理是形如 $\exists xP(x)$ 的命题。通过找到一个使 $P(a)$ 为真的元素 $a$ 来给出 $\exists xP(x)$ 为真的证明方法被称为构造性的（constructive）；不通过找到这样的 $a$，而是使用归谬证明，证明该量化式的否定蕴含着一个矛盾，以此说明存在性的证明方法被称为非构造性的。

<br>

> **问题 4 构造性的存在性证明**
>
> 证明存在一个正整数，可以用两种不同的方式将其表示为正整数的立方和

<br>

证明：存在 $1729=10^3+9^3=12^3+1^3$ 和 $4104=9^3+15^3=2^3+16^3$，故命题成立。这可以通过计算机来寻找，例如以下就是一个寻找 Taxicab 数的JavaScript程序：

<br>

``` javascript
function tuple(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;
}
let searchSup = 10000;
let resultArray = [];
let count = 0;
for (let i = 1; i <= searchSup; i++) {
    for (let j = 1; j ** 3 <= i; j++) {
        let roughResult = Math.ceil((i - j ** 3) ** (1 / 3));
        for (let a = roughResult; a ** 3 + j ** 3 >= i && a > 0; a--) {
            if (a ** 3 + j ** 3 === i) {
                resultArray[count] = new tuple(a, j, i);
                count++;
            }
        }
    }
}
let search = 0;
for (let i = 0; i <= count - 1; i = search + 1) {
    search = i;
    let repeat = 0;
    while (search <= count - 1 &&
           resultArray[search].c === resultArray[i].c) {
        repeat++;
        search++;
    }
    if (repeat >= 4) {
        for (let j = i; j < search; j += 2) {
            console.log(`(${resultArray[j].a}, ${resultArray[j].b}, ${resultArray[j].c})`);
        }
    }
}
```

<br>

> **问题 5 非构造性的存在性证明**
>
> 证明存在无理数 $x$ 和 $y$ 使得 $x^y$ 为有理数

<br>

考虑数 $\sqrt{2}^{\sqrt{2}}$。如果它是有理数，则命题成立，这是因为 $\sqrt{2}$ 是无理数；如果它是无理数，构造 $(\sqrt{2}^{\sqrt{2}})^{\sqrt{2}} = (\sqrt{2})^2=2$ 为有理数，因此命题依旧成立。由这两种情况可知命题成立。

<br>

<br>

<br>

## 2 计数方法

<br>

### 2.1 计数的基本原理

<br>

> **命题 2.1-1 乘法原理**
>
> 假定一个过程可以被分解成两个任务。如果完成第一个任务有 $n_1$ 种方法，在第一个任务完成之后有 $n_2$ 种方法完成第二个任务，那么完成这个过程有 $n_1n_2$ 种方法。
>
> 可以将乘法原理进行推广，假定一个过程由执行任务 $T_1,\cdots,T_m$ 来完成，如果完成任务之后用 $n_i$ 种方式来完成任务 $T_i(i=1,\cdots,m)$，那么完成这个过程总共有 $n_1\times\cdots\times n_m$ 种方式

<br>

推广的乘法原理证明：考虑使用数学归纳法进行证明。当 $m=2$ 时，命题成立；假设命题对某个自然数 $m(m\geq 2)$ 成立，即完成所有任务 $T_1,\cdots,T_m$ 总共有 $n_1\times\cdots\times n_m$ 种方法；那么将前 $m$ 个任务看作一个独立的任务，同样可以得到对于所有任务 $T_1,\cdots,T_m,T_{m+1}$，完成这些任务总共有 $(n_1\times\cdots\times n_m)\times n_{m+1}$ 种方法。推广的乘法原理成立。

<br>

> **命题 2.1-2 加法原理**
>
> 完成一项任务有两类方法，第一类方法中有 $n_1$ 种方法，第二类方法中有 $n_2$ 种方法，则完成这项任务总共有 $n_1+n_2$ 种方法。
>
> 可以将加法原理进行推广，完成一项任务总共有 $m$ 类方式，第 $i$ 类方式中有 $n_i(i=1,\cdots,n)$ 种具体的方式，则完成这项任务总共有 $n_1+\cdots+n_m$ 种方式

<br>

与乘法原理相同，加法原理也可以使用数学归纳法证明：当 $m=2$ 时，命题成立；假设命题对某个自然数 $m(m\geq 2)$ 成立，即完成一项任务，若有 $m$ 类方式，且第 $i$ 类方式有 $n_i$ 种具体方式，则完成这个任务总共有 $n_1+\cdots+n_m$ 种方式；对于 $m+1$ 的情况，可以将前 $m$ 类方式都看作一类新的方式，因此完成这些任务总共有 $(n_1+\cdots+n_m)+n_{m+1}$ 种方式。推广的加法原理成立。推广的加法原理也可以用集合的语言描述：

$$
    \#\left(\bigcup_{i=1}^mA_i\right)=\sum_{i=1}^m\#(A_i),\quad 1\leq i,j\leq m,i\neq j,A_i\cap A_j=\emptyset
$$

<br>

> **命题 2.1-3 减法原理（容斥原理）**
>
> 如果一个任务或者可以通过 $n_1$ 种方法执行，或者可以通过 $n_2$ 种方法执行，那么完成这个任务的方法数是 $n_1+n_2$ 减去两类方法中相同的方法。容斥原理（principle of inclusion and exclusion）也可以用集合的语言描述：
>
> $$
    \#(A_1\cup A_2)=\#(A_1)+\#(A_2)-\#(A_1\cap A_2)
>    $$
>
> 容斥原理也具有推广形式，设 $A_1,\cdots,A_n$ 是有穷集，那么
>
> $$
    \begin{aligned}
    \#\left(\bigcup_{i=1}^nA_i\right)=\sum_{1\leq i\leq n}\#(A_i)&-\sum_{1\leq i<j\leq n}\#(A_i\cap A_j)\\
    +\sum_{1\leq i<j<k\leq n}\#(A_i\cap A_j\cap A_k)-&\cdots+(-1)^{n+1}\#(A_1\cap\cdots\cap A_n)
    \end{aligned}
>   $$

<br>

容斥原理的推广形式可以这样证明：通过证明并集的每个元素在等式右边恰好被计数 $1$ 次。假设 $a$ 恰好是 $A_1,\cdots,A_n$ 中 $r$ 个集合的成员，其中 $1\leq r\leq n$。这个元素被 $$ \sum\#(A_i) $$ 计数了 $\displaystyle\binom{r}{1}$ 次，被 $$ \sum\#(A_i\cap A_j) $$ 计数了 $\displaystyle\binom{r}{2}$ 次。一般地，涉及 $m$ 个 $A_i$ 集合的求和被计数了 $\displaystyle\binom{r}{m}$ 次。于是这个元素在等式右侧计数了

$$
    \binom{r}{1}-\binom{r}{2}+\binom{r}{3}+\cdots+(-1)^{r+1}\binom{r}{r}
$$

次，根据熟知的二项式定理（虽然在笔记里这是后面的内容）可知

$$
    (1+(-1))^r=\binom{r}{0}1^r+\binom{r}{1}1^{r-1}(-1)^1+\cdots+\binom{r}{r}(-1)^r
$$

因此可以得到计数次数恰好为 $1$，推广的容斥原理成立。

<br>

容斥原理有另一种表述形式，它在计数问题中比较常用，这种形式可以用于求解在一个集合中的元素数，使得这些元素不具有 $n$ 个性质 $P_1,P_2,\cdots,P_n$ 中的任意一条性质。设 $A_i$ 是具有性质 $P_i$ 的元素的子集，具有这些性质 $P_{i_1},P_{i_2},\cdots, P_{i_k}$ 的元素数记为 $N(P_{i_1}\cdots P_{i_k})$，用集合的语言描述就是

$$
    \#\left(\bigcap_{j=1}^kA_{i_j}\right)=N(P_{i_1}\cdots P_{i_k})
$$

如果将不具有 $n$ 个性质 $P_1,\cdots, P_n$ 中的任何一个的元素数记为 $N(\bar{P_1}\cdots\bar{P_n})$，那么根据容斥原理有

$$
    N(\bar{P_1}\cdots\bar{P_n})=N-\sum_{1\leq i\leq n}N(P_i)+\sum_{1\leq i<j\leq n}N(P_iP_j)
$$

$$
    -\sum_{1\leq i<j<k\leq n}N(P_iP_jP_k)+\cdots+(-1)^nN(P_1\cdots P_n)
$$

<br>

错位排列问题是使得没有一个物体在它的初始位置上的排列，它可以使用容斥原理求得，我们先给出错位排列数的表达式：

<br>

> **命题 2.1-4 错位排列数**
>
> $n$ 元素集合的错位排列数是
>
> $$
    D_n=n!\left[1-\frac{1}{1!}+\frac{1}{2!}+\cdots+(-1)^n\frac{1}{n!}\right]
>   $$

<br>

证明：如果排列保持了元素 $i$ 不变，则设排列有性质 $P_i$，错位排列数就是对 $i=1,\cdots,n$ 都没有性质 $P_i$ 的排列数，即

$$
    D_n=N(\bar{P_1}\cdots\bar{P_n})
$$

根据容斥原理

$$
    N(\bar{P_1}\cdots\bar{P_n})=N-\sum_{1\leq i\leq n}N(P_i)+\sum_{1\leq i<j\leq n}N(P_iP_j)
$$

$$
    -\sum_{1\leq i<j<k\leq n}N(P_iP_jP_k)+\cdots+(-1)^nN(P_1\cdots P_n)
$$

我们知道 $N(P_i)$ 表示的是保持 $i$ 元素不动，其余元素可以随意摆放的排列数，其值为 $(n-1)!$，同理我们知道 $N(P_iP_j)=(n-2)!$ 和 $N(P_iP_jP_k)=(n-3)!$，因此我们最终可以得到

$$
    \begin{aligned}
        D_n&=n!-\binom{1}{n}(n-1)!+\cdots+(-1)^n\binom{n}{n}0!\\
        &=n!-\frac{n!}{1!}+\frac{n!}{2!}+\cdots+(-1)^n\frac{n!}{n!}\\
        &=n!\left[1+\frac{1}{1!}-\frac{1}{2!}+\cdots+(-1)^n\frac{1}{n!}\right]
    \end{aligned}
$$

对于一个随机排列，其错位排列的概率是：

$$
    P_n=\frac{D_n}{n!}=1+\frac{1}{1!}-\frac{1}{2!}+\cdots+(-1)^n\frac{1}{n!}
$$

当 $n$ 趋向于无穷大时，根据 $\mathrm{e}^x$ 的生成函数

$$
    \mathrm{e}^x=1+x+\frac{1}{2!}x^2+\cdots=\sum_{k=0}^\infty \frac{x^k}{k!}
$$

知极限概率为

$$
    \lim_{n\to\infty}P_n=\lim_{n\to\infty}\left[1+\frac{1}{1!}-\frac{1}{2!}+\cdots+(-1)^n\frac{1}{n!}\right]=\frac{1}{\mathrm{e}}
$$

<br>

### 2.2 鸽巢原理

<br>

> **命题 2.2-1 鸽巢原理（pigeonhole principle）**
>
> 如果 $k+1$ 个或更多的物体放入 $k$ 个盒子，那么至少有一个盒子包含了 $2$ 个或者更多的物体

<br>

证明：使用反证法，假定 $k$ 个盒子中没有一个包含物体的数量多于 $1$ 个，那么物体总数至多是 $k$ 个，这与至少有 $k+1$ 个物体的前提矛盾。

<br>

> **命题 2.2-2 广义鸽巢原理**
>
> 如果 $N$ 个物体放入 $k$ 个盒子，那么至少有一个盒子包含了至少 $\displaystyle\left\lceil\frac{N}{k}\right\rceil$ 个物体

<br>

证明：使用反证法，假定没有盒子包含了比 $\displaystyle\left\lceil\frac{N}{k}\right\rceil-1$ 多的物体，那么物体总数至多是

$$
    k\left(\left\lceil\frac{N}{k}\right\rceil-1\right)<k\left(\left(\frac{N}{k}+1\right)-1\right)=N
$$

这与至少存在 $N$ 个物体的前提矛盾，根据反证法可知广义鸽巢原理成立。

<br>

> **问题**
>
> 证明：对每个整数 $n$，存在一个数是 $n$ 的倍数且在它的十进制中只出现 $0$ 和 $1$

证明：令 $n$ 是正整数，考虑 $n+1$ 个整数 $1,11,111,\cdots,\overbrace{1\cdots 1}^{n+1}$。注意到当一个整数被 $n$ 整除时存在 $n$ 个可能的余数，在给定的这 $n+1$ 的整数中，对 $n$ 进行整除操作，根据鸽巢原理可知必存在两个整数在整除 $n$ 时具有相同的余数。这两个整数之差的十进制表示中只有 $0$ 和 $1$ 且能被 $n$ 整除（因为它们的余数相同）。

<br>

上述构造方法只能给出存在性，如果需要求最小的满足条件的数，可以考虑构造一系列二进制串，判断能否整除 $n$，以下是这个思路的JavaScript程序：

<br>

``` javascript
let n = 121;
let testSup = 1023;
let flag = false;
for (let i = 1; i <= testSup && !flag; i++) {
    let binaryNum = i;
    let binaryStr = "";
    for (let j = 1; j <= Math.floor(Math.log2(i)) + 1; j++) {
        binaryStr = binaryNum % 2 + binaryStr;
        binaryNum = Math.floor(binaryNum / 2);
    }
    if (Number(binaryStr) % n === 0) {
        flag = true;
        console.log(binaryStr);
        console.log(Number(binaryStr) / n);
        break;
    }
}
```

<br>

### 2.3 排列组合

<br>

> **定义 2.3-1 排列（permutation）**
>
> 集合中不同元素的排列，是对这些元素的一种有序安排，而对一个集合中 $r$ 个元素进行排列的方式称为 $r$ 排列。具有 $n$ 个不同元素的集合的 $r$ 排列数是
>
> $$
    (n)_r=n(n-1)\cdots(n-r+1)=\frac{n!}{(n-r)!}
>   $$

<br>

> **定义 2.3-2 组合（combination）**
>
> 集合中不同元素的组合，是对这些元素的一种无序选取，而对一个集合中 $r$ 个元素进行组合的方式称为 $r$ 组合。具有 $n$ 个不同元素的集合的 $r$ 组合数是
>
> $$
    \binom{n}{r}=\frac{(n)_r}{(r)_r}=\frac{n!}{r!(n-r)!}
>   $$

<br>

排列组合有很多有意思的经典模型问题
- 有重复的排列：具有 $n$ 个物体的集合允许重复的 $r$ 排列数是 $n^r$；
- 有重复的组合：当允许重复时，$n$ 元素集合的每个 $r$ 组合可以用 $n-1$ 条竖线和 $r$ 个元素来表示。这 $n-1$ 条竖线用于标记 $n$ 个不同的单元，当集合的第 $i$ 个元素出现在组合中时，第 $i$ 个单元包含一个元素，例如 $4$ 元素集合的一个 $6$ 组合就可以用 $3$ 条竖线和 $6$ 个元素表示：`**|*||***`。这相当于在 $n+r-1$ 个位置中放入 $r$ 个元素的问题，故可重复的 $r$ 组合数为

    $$
        \binom{n+r-1}{r}=\binom{n+r-1}{n-1}
    $$

    一个比较有意思的等同于有重复组合的问题是如下的嵌套循环问题：

    ``` pseudocode
    k := 0
    for i_1 := 1 to n
        for i_2 := 1 to i_1
            ...
            for i_m := 1 to i_{m-1}
                k := k + 1
    ```

    执行上面的伪代码之后 $k$ 的值是 $\displaystyle\binom{n+m-1}{m}$，因为这本质上是寻找一个长度为 $m$ 的非递增序列，且所有元素都不超过 $n$。注意到任意从 $1,\cdots,n$ 中寻找 $m$ 个数（可重复），寻找到的 $m$ 个数都能经过降序排序得到一个非递增的序列，因此实际上选取是无序的，所以这等价于 $n$ 元素集的可重复 $m$ 组合问题。

- 具有部分不可区分物体集合的排列：设类型 $1$ 的相同的物体有 $n_1$ 个，类型 $2$ 的相同的物体有 $n_2$ 个，以此类推，类型 $k$ 的相同的物体有 $n_k$ 个，那么所有 $n$ 个物体的不同排列数是

    $$
        \frac{n!}{n_1!n_2!\cdots n_k!}
    $$

- 可辨别的物体放入可辨别的盒子：该问题等价于具有部分不可区分物体集合的排列问题，因为本质上不可区分的物体是排除了这些物体排列的可能，而放入盒子这一操作并不关心物体在盒子内的排列顺序，同样排除了排列的可能。把 $n$ 个不同的物体分配给 $k$ 个不同的盒子使得 $n_i$ 个物体放入盒子 $i$ 的方法数为

    $$
        \frac{n!}{n_1!n_2!\cdots n_k!}
    $$

- 不可辨别的物体放入可辨别的盒子：该问题等价于有重复的组合问题，这从此前使用过的竖线-元素模型中可以看出。把 $r$ 个不可辨别的物体放入 $n$ 个可辩别的盒子中的方法数是

    $$
        \binom{n+r-1}{r}=\binom{n+r-1}{n-1}
    $$

- 可辨别的物体放入不可辨别的盒子：该问题等价于一个集合划分为不相交的非空子集的问题。设 $S(n,j)$ 表示将 $n$ 个可辨别的物体放入 $j$ 个不可辨别的盒子的方法数，其中不允许有空的盒子。我们考虑与之类似的一个问题：从 $n$ 元素集到 $j$ 元素集的满射个数。假定值域中的元素为 $b_1,\cdots,b_j$，设性质 $P_i$ 表示元素 $b_i$ 不在映射值域内的性质，则该问题所求的是 $N(\bar{P_1}\cdots\bar{P_n})$，则根据容斥原理

    $$
        N(\bar{P_1}\cdots\bar{P_n})=\sum_{i=0}^{j-1}(-1)^i\binom{j}{i}(j-i)^n
    $$

    其中 $(j-i)^n$ 指的是从 $n$ 元素集合到 $j-i$ 元素集合的映射个数，$\displaystyle\binom{j}{i}$ 指的是从 $j$ 元素集剔除 $i$ 个元素的方法数。根据题意，集合内的元素是可辨别的，故 $S(n,j)$ 还需要 $N(\bar{P_1}\cdots\bar{P_n})$ 除以 $j$ 个元素的排列数：

    $$
        S(n,j)=\frac{1}{j!}\sum_{i=0}^{j-1}(-1)^i\binom{j}{i}(j-i)^n
    $$

    $S(n,j)$ 被称为**第二类 Stirling 数**。而将 $n$ 个可辨别的物体放入 $k$ 个不可辨别的盒子（允许有空）的方法数是

    $$
        \sum_{j=1}^kS(n,j)=\sum_{j=1}^k\frac{1}{j!}\sum_{i=0}^{j-1}(-1)^i\binom{j}{i}(j-i)^n
    $$

<br>

#### 2.3.1 生成排列算法

<br>

任何 $n$ 元素集合都可以与集合 $$ \{1,2,\cdots, n\}$$ 建立双射。我们可以构建算法按照字典顺序生成排列（字典顺序指，如果对于某个 $k(1\leq k\leq n)$，$a_1=b_1,a_2=b_2,\cdots,a_{k-1}=b_{k-1},a_k<b_k$，则排列 $a_1\cdots a_n$ 在排列 $b_1\cdots b_n$ 前面）。

<br>

生成排列的算法基础是从一个给定排列 $a_1\cdots a_n$ 按照字典顺序构造下一个排列的过程，可以描述一个一般的方法来生成下一个排列：
- 首先，找到整数 $j$ 使得 $a_j<a_{j+1}$ 且

    $$
        a_{j+1}>a_{j+2}>\cdots>a_n
    $$

    即找到这个排列中最后相邻的整数，使得这个对的第一个整数小于第二个整数；
- 然后，把 $a_{j+1},\cdots,a_n$ 中大于 $a_j$ 的最小整数放到第 $j$ 个位置；
- 再按照递增顺序从位置 $j+1$ 到 $n$ 列出 $a_j,a_{j+1},\cdots,a_n$ 中其余的整数。


<br>

> **算法 2.3-1 生成下一个排列**
>
> ``` pseudocode
> procedure | next permutation
> (a_1...a_n : {1,...,n})
> 
> j := n - 1
> while a_j > a_{j+1}
>     j := j - 1
> // j is the biggest subscript that permits a_j < a_{j+1}
> k := n
> while a_j > a_k
>     k := k - 1
> // a_k is the smallest integer, it is greater than a_j and is on the right of a_j
> SWAP(a_j, a_k)
> r := n
> s := j + 1
> while r > s
>     SWAP(a_r, a_s)
>     r := r - 1
>     s := s + 1
> ```

<br>

以下是根据该算法写出的生成所有排列的C++程序：

<br>

``` cpp
#include <iostream>
#include <string>

void swap(int* a, int* b);

int main() {
    int n = 6;
    int per[n];
    bool flag = false;
    std::string perStr = "";
    for (int i = 1; i <= n; i++) {
        per[i - 1] = i;
        perStr += std::to_string(per[i - 1]);
    }
    perStr += "\n";
    while (true) {
        int t = 0;
        while (t <= n - 1 && per[t] == n - t)
            t++;
        if (t == n)
            break;
        int j = n - 2;
        while (j >= 0 && per[j] > per[j + 1])
            j--;
        int k = n - 1;
        while (k >= 0 && per[j] > per[k])
            k--;
        swap(&per[j], &per[k]);
        int r = n - 1;
        int s = j + 1;
        while (r > s) {
            swap(&per[r], &per[s]);
            r--;
            s++;
        }
        for (int i = 1; i <= n; i++)
            perStr += std::to_string(per[i - 1]);
        perStr += "\n";
    }
    std::cout << perStr;
    return 0;
}

void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}
```

<br>

#### 2.3.2 生成组合算法

<br>

一个有穷集的一个组合相当于它的子集，我们可以在集合 $$ \{a_1,\cdots,a_n\} $$ 的子集与 $n$ 位比特串之间建立双射关系。如果 $a_k$ 在子集中，对应的比特串在第 $k$ 位是 $1$，否则为 $0$。

<br>

生成组合的算法基础是找到按照字典顺序找到下一个比特串，可以描述一个一般的方法来生成下一个组合（本质上是进位）：
- 首先，找到整数 $j$ 使得 $a_j=0$ 且 $a_{j+1}=\cdots=a_n=1$；
- 将 $a_j$ 变为 $1$，$a_{j+1},\cdots,a_n$ 变为 $0$。

<br>

> **算法 2.3-2 生成下一个组合**
>
> ``` pseudocode
> procedure | next bit string
> 
> i := 0
> while b_i = 1
>     b_i = 0
>     i := i + 1
> b_i = 1
> ```

<br>

以下是根据该算法写出的生成所有组合的C++程序：

<br>

``` cpp
#include <iostream>
#include <string>

int main() {
    int n = 6;
    int com[n];
    std::string comStr = "";
    for (int i = 1; i <= n; i++) {
        com[i - 1] = 0;
        comStr += std::to_string(com[i - 1]);
    }
    comStr += "\n";
    while (true) {
        int t = 0;
        while (t <= n - 1 && com[t] == 1)
            t++;
        if (t == n)
            break;
        int i = 0;
        while (com[i] == 1) {
            com[i] = 0;
            i++;
        }
        com[i] = 1;
        for (int i = n; i >= 1; i--)
            comStr += std::to_string(com[i - 1]);
        comStr += "\n";
    }
    std::cout << comStr;
    return 0;
}
```

<br>

有时候我们需要给出的是集合的所有 $r$ 组合。根据之前讨论过的嵌套循环问题，我们知道一个 $r$ 组合可以表示成一个序列，这个序列按照递增的顺序（在前面的嵌套循环中是一个非递增，而这里是一个不可重复问题）包含了这个子集的元素，使用这些序列的字典顺序可以列出这些 $r$ 组合。在该字典顺序下，$$ \{1,\cdots, r\}$$ 是第一个组合， $$ \{n-r+1,\cdots,n\} $$ 是最后一个组合。

<br>

在 $r$ 组合 $a_1\cdots a_r$ 后面的下一个组合可以按照以下方法生成：
- 首先，找到最大的整数 $i$ 使得 $a_i\neq n-r+i$，其中 $n-r+i$ 就代表尾部元素的值；
- 然后，用 $a_i+1$ 代替 $a_i$，且对于 $j=i+1,\cdots,r$，用 $a_i+1+j-i$ 代替 $a_j$。第一步是逐渐将从头部过来的元素往尾部移动，第二步是将之前已经移动到尾部的元素向第一步移动的元素靠拢。

<br>

> **算法 2.3-3 生成下一个 $r$ 组合**
>
> ``` pseudocode
> procedure | next r-combination
> 
> i := r
> while a_i = n - r + i
>     i := i - 1
> // i is the smallest subscript that permits a_i != n - r + i
> a_i := a_i + 1
> for j := i + 1 to r
>     a_j := a_i + j - i
> // Here, a_i has already changed to a_i + 1
> ```

<br>

以下是根据该算法写出所有 $r$ 组合的C++程序：

<br>

``` cpp
#include <iostream>
#include <string>

int main() {
    int n = 6;
    int r = 4;
    int com[r];
    std::string comStr = ""; 
    for (int i = 1; i <= r; i++) {
        com[i - 1] = i;
        comStr += std::to_string(com[i - 1]);
    }
    comStr += "\n";
    while (true) {
        int t = 1;
        while (t <= r && com[t - 1] == n - r + t)
            t++;
        if (t == r + 1)
            break;
        int i = r;
        while (i >= 1 && com[i - 1] == n - r + i)
            i--;
        com[i - 1]++;
        for (int j = i + 1; j <= r; j++)
            com[j - 1] = com[i - 1] + j - i;
        for (int p = 1; p <= r; p++)
            comStr += std::to_string(com[p - 1]);
        comStr += "\n";
    }
    std::cout << comStr;
    return 0;
}
```

<br>

### 2.4 二项式

<br>

> **命题 2.4-1 二项式定理**
>
> 设 $x,y$ 是变量，$n$ 是非负整数，则
>
> $$
    (x+y)^n=\sum_{j=0}^n\binom{n}{j}x^{n-j}y^j
>   $$

<br>

这里给出二项式定理的组合学理解，$x^{n-j}y^j$ 可以理解为在 $n$ 个变量中设置 $j$ 个变量 $y$ 和 $n-j$ 个变量 $x$，方法数是 $\displaystyle\binom{n}{j}$，因此该展开式就是 $j$ 从 $0$ 到 $n$ 的和。

<br>

> **命题 2.4-2 Pascal 恒等式**
>
> 设 $n$ 和 $k$ 是满足 $n\geq k$ 的正整数，那么有
>
> $$
    \binom{n+1}{k}=\binom{n}{k-1}+\binom{n}{k}
>   $$

<br>

这里给出 Pascal 恒等式的组合学理解，假设 $T$ 是包含 $n+1$ 个元素的集合，令 $a$ 是 $T$ 的一个元素，令 $$ S:=T-\{a\} $$，$T$ 的基数为 $k$ 的子集有 $\displaystyle\binom{n+1}{k}$ 个。不包含 $a$ 的所有子集都是 $S$ 的子集，这部分子集个数为 $\displaystyle\binom{n}{k}$；包含 $a$ 的所有子集，其去除 $a$ 构成的集合是 $S$ 的子集，这部分子集个数为 $\displaystyle\binom{n}{k-1}$，因此有 Pascal 恒等式成立。

<br>

> **命题 2.4-3 Van der Monde 恒等式**
>
> 设 $m,n,r$ 为非负整数，其中 $r\leq m$ 或者 $r\leq n$，那么有
>
> $$
    \binom{m+n}{r}=\sum_{k=0}^r\binom{m}{k}\binom{n}{r-k}
>   $$

<br>

这里给出 Van der Monde 恒等式的组合学理解，假设 $T$ 是包含 $m+n$ 个元素的集合，其可以被划分为两个子集，第一个子集 $T_1$ 满足 $$ \#(T_1)=m $$，第二个子集 $T_2$ 满足 $$ \#(T_2)=n $$，从集合 $T$ 中选取 $r$ 个元素的方法数是 $\displaystyle\binom{m+n}{r}$。

我们可以从集合 $T_1$ 中取 $k$ 个元素，再从集合 $T_2$ 中取 $r-k$ 个元素，由乘法原理可知方法数为 $\displaystyle\binom{m}{k}\binom{n}{r-k}$，因此总方法数为

$$
    \sum_{k=0}^r\binom{m}{k}\binom{n}{r-k}
$$

<br>

### 2.5 递推

<br>

#### 2.5.1 递推问题

<br>

> **问题 1 汉诺塔问题**
>
> 汉诺塔由安装在一个板子上的 $3$ 根柱子和若干个大小不同的盘子组成。开始时，这些盘子按照大小的次序放在第一根柱子上，大盘子在底下。游戏的规则是：每一次把 $1$ 个盘子从一根柱子移动到另一根柱子上，但是不允许这个盘子放在比它小的盘子上面。游戏的目标是把所有的盘子按照大小次序都放到第二根柱子上，最大的盘子放在底部。
>
> ```
>     |                |               |
>    -+-               |               |
>   --+--              |               |
>  ---+---             |               |
> ----+----            |               |
> ```

<br>

首先需要明确的是，柱子之间并没有次序关系，它们是等价的（因为没有只能到达相邻柱子的要求）。用 $H_n$ 表示解 $n$ 个盘子的汉诺塔问题所需要的移动次数，开始时 $n$ 个盘子在柱 $1$。我们可以用 $H_{n-1}$ 次移动将上边的 $n-1$ 个盘子移动到柱 $3$（因为最大的盘子留在底部时对移动无影响），然后用一次移动将最大的盘子移动到柱 $2$，再用 $H_{n-1}$ 次移动将柱 $3$ 的 $n-1$ 个盘子移动到柱 $2$。则我们可以给出如下的递推关系：

$$
    H_n=2H_{n-1}+1
$$

初始条件是 $H_1=1$，令 $L_n=H_n+1$，很明显 $L_n$ 是一个等比数列，其首项为 $2$，公比为 $2$，于是 $L_n=2^n$，$H_n=2^n-1$。

<br>

> **问题 2 动态规划的一个实例**
>
> 设有 $n$ 场讲座，讲座 $j$ 开始于时间 $s_j$，结束于时间 $e_j$，有 $w_j$ 个学生参与，两个讲座不可以安排在同一时间，一个讲座可在另一个讲座结束时开始。我们需要规划最大的参与学生人数，即我们希望规划一个讲座安排使得在所有安排的讲座中 $w_j$ 之和最大

<br>

首先我们将这几个讲座按照结束时间升序排序并重新编号，满足 $e_1\leq\cdots\leq e_n$，我们称两个讲座之间是相容的，能够成为动态规划的一部分，当且仅当它们的时间不会重叠。对于第 $j$ 个讲座，定义 $\text{close}(j)$ 为满足 $e_i\leq s_j$ 的最大整数 $i$，即在时间表上，第 $i$ 个讲座的结束时间是在第 $j$ 个讲座开始时间之前最靠近的，如果不存在，则记 $\text{close}(j)=0$。以下就是一个事件表：

<br>

``` plaintext
7                       ▒▒▒▒▒▒▒▒    close(7) = 4
6              ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒    close(6) = 2
5  ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒    close(5) = 0
4      ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒              close(4) = 0
3           ▒▒▒▒▒▒▒                 close(3) = 1
2    ▒▒▒▒▒▒▒▒▒                      close(2) = 0
1 ▒▒▒▒▒▒▒▒                          close(1) = 0
```

<br>

设 $\text{best}(j)$ 表示由一个调度得到的前 $j$ 场讲座的学生最大参与数，则 $\text{best}(n)$ 就是我们最终需要求的答案。考虑前 $j$ 次讲座的学生参与调度，我们知道讲座 $\text{close}(j)+1,\cdots,j-1$ 不可能属于这个调度，因为它们与讲座 $j$ 是不相容的。
- 当讲座 $j$ 可以安排到前 $\text{close}(j)$ 个讲座的调度中时，此时最大参与数为 $\text{best}(j)=w_j+\text{best}(\text{close}(j))$；
- 当讲座 $j$ 安排不进前 $\text{close}(j)$ 个讲座的调度中时（这说明 $\text{close}(j)=0$），保持 $\text{best}(j)=\text{best}(j-1)$。

综合以上两种情形可以得到最终的递推形式：

$$
    \text{best}(j)=\max(w_j+\text{best}(\text{close}(j)),\text{best}(j-1))
$$

写作伪代码如下：

<br>

``` pseudocode
procedure | maximum attendees
s_1,...,s_n : The start time of lectures
e_1,...,e_n : The end time of lectures
w_1,...,w_n : The number of attendees

SORT(e_i, <)
for j := 1 to n
    if !E i(i < j) => e_i < s_j
        close(j) := 0
    else
        close(j) := MAXOF(i), i(i < j) => e_i < s_j
best(0) := 0
for j := 1 to n
    best(j) := MAX(w_j + best(close(j)), best(j - 1))
return best(n)
```

<br>

以下是根据该算法写出的C++程序：

<br>

``` cpp
#include <iostream>

struct lecture {
    int s;  // start time
    int e;  // end time
    int w;  // attendees
    int i;  // index
};

void swap(lecture& a, lecture& b);

int main() {
    int close[7];
    int best[7];
    lecture l[6] = {
        {8,  10, 23},
        {9,  18, 90},
        {12, 16, 45},
        {10, 17, 64},
        {9,  13, 26},
        {16, 18, 34}
    };
    for (int k = 0; k <= 5; k++)
        l[k].i = k;
    for (int j = 0; j <= 4; j++) {
        for (int k = 0; k <= 5 - j - 1; k++) {
            if (l[k].e > l[k + 1].e) {
                swap(l[k], l[k + 1]);
            }
        }
    }
    for (int j = 1; j <= 6; j++) {
        close[j] = 0;
        for (int k = 1; k <= 6; k++) {
            if (l[k - 1].e <= l[j - 1].s)
                close[j] = k;
        }
    }
    best[0] = 0;
    for (int j = 1; j <= 6; j++)
        best[j] = l[j - 1].w + best[close[j]] > best[j - 1] ?
            l[j - 1].w + best[close[j]] : best[j - 1];
    std::cout << best[6];
    return 0;
}

void swap(lecture& a, lecture& b) {
    int t1, t2, t3, t4;
    t1 = a.s; a.s = b.s; b.s = t1;
    t2 = a.e; a.e = b.e; b.e = t2;
    t3 = a.w; a.w = b.w; b.w = t3;
    t4 = a.i; a.i = b.i; b.i = t4;
}
```

<br>

#### 2.5.2 线性递推关系

<br>

> **定义 2.5-1 常系数线性齐次递推关系**
>
> 一个常系数的 $k$ 阶线性齐次递推关系是形如
>
> $$
    a_n=c_1a_{n-1}+\cdots+c_ka_{n-k}
>   $$
>
> 的递推关系，其中 $c_1,\cdots,c_k$ 是实数，$c_k\neq 0$

<br>

根据数学归纳法第二原理，这个序列由这个递推关系和 $k$ 个限制条件确定。根据经验，这些递推关系具有 $a_n=r^n(r\neq 0)$ 的解，其中 $r$ 是常数，当其为上述递推方程的解时有：

$$
    r^k-c_1r^{k-1}-c_2r^{k-2}-\cdots-c_k=0
$$

这个方程称为递推关系的特征方程，方程的解为该递推关系的特征根。

<br>

注意到，线性齐次递推关系的解的线性组合也是递推关系的解，所以可以找到一组基来表示 $a_n$。设上述特征方程分别有 $k$ 个不相同的根 $r_1,\cdots,r_k$，此时

$$
    a_n=\alpha_1r_1^n+\alpha_2r_2^n+\cdots+\alpha_kr_k^n
$$

其中 $\alpha_1,\cdots,\alpha_k$ 是待解的系数。

<br>

如果上述方程有 $t$ 个不相等的根 $r_1,\cdots,r_t$，其重根数为 $m_1,\cdots,m_t$，满足 $m_i\geq 1(i=1,\cdots,t)$，且 $m_1+\cdots+m_t=k$，此时

$$
    \begin{aligned}
        a_n=&(\alpha_{1,0}+\alpha_{1,1}n+\cdots+\alpha_{1,m_1-1}n^{m_1-1})r_1^n\\
        &+(\alpha_{2,0}+\alpha_{2,1}n+\cdots+\alpha_{2,m_2-1}n^{m_2-1})r_2^n\\
        &+\cdots+(\alpha_{t,0}+\alpha_{t,1}n+\cdots+\alpha_{t,m_t-1}n^{m_t-1})r_t^n
    \end{aligned}
$$

其中 $\alpha_{i,j}$，$1\leq i\leq t$ 和 $1\leq j\leq m_i-1$ 是待解的系数。

<br>

> **定义 2.5-2 常系数线性非齐次递推关系**
>
> 一个常系数的 $k$ 阶线性非齐次递推关系是形如
>
> $$
    a_n=c_1a_{n-1}+\cdots+c_ka_{n-k}+F(n)
>   $$
>
> 的递推关系，其中 $c_1,\cdots,c_k$ 是实数，$F(n)$ 是只依赖于 $n$ 且不恒为 $0$ 的函数。该递推关系具有一个相伴的齐次递推关系：
>
> $$
    a_n=c_1a_{n-1}+\cdots+c_ka_{n-k}
>   $$

<br>

如果 $a_n^{(p)}$ 是非齐次递推关系的一个特解，那么每个解都是 $a_n^{(p)}+a_n^{(h)}$ 的形式，其中 $a_n^{(h)}$ 是相伴的齐次递推关系的解。

<br>

### 2.6 生成函数

<br>

> **定义 2.6-1 生成函数**
>
> 对于一个实数序列 $a_0,a_1,\cdots,a_k,\cdots$ 的生成函数是无穷级数
>
> $$
    G(x)=a_0+a_1x+\cdots+a_kx^k+\cdots=\sum_{k=0}^\infty a_kx^k
>   $$

<br>

> **命题 2.6-1 生成函数之间的运算**
>
> 令 $f(x)=\sum_{k=0}^\infty a_kx^k$，$g(x)=\sum_{k=0}^\infty b_kx^k$，那么
>
> $$
    \begin{aligned}
        f(x)+g(x)&=\sum_{k=0}^\infty(a_k+b_k)x^k\\
        f(x)g(x)&=\sum_{k=0}^\infty\left(\sum_{j=0}^ka_jb_{k-j}\right)x^k
    \end{aligned}
>   $$

<br>

除了使用以上的加法和乘法运算给出新的生成函数，通过一个生成函数得到另一个生成函数的方法还有微分运算，例如我们知道

$$
    \frac{1}{1-x}=1+x+x^2+\cdots=\sum_{k=0}^\infty x^k
$$

两边求微分可以得到

$$
    \frac{1}{(1-x)^2}=1+2x+3x^2+\cdots=\sum_{k=0}^\infty(k+1)x^k
$$

<br>

> **定义 2.6-2 广义二项式系数**
>
> 设 $u$ 是实数且 $k$ 是非负整数，那么广义二项式系数 $\displaystyle\binom{u}{k}$ 定义为
>
> $$
    \binom{u}{k}=\begin{cases}
        \displaystyle\frac{u(u-1)\cdots(u-k+1)}{k!}&,k>0\\
        1&,k=0
    \end{cases}
>   $$

<br>

> **命题 2.6-2 广义二项式定理**
>
> 设 $x$ 是实数，$\lvert x\rvert<1$，$u$ 是实数，那么
>
> $$
    (1+x)^u=\sum_{k=0}^\infty\binom{u}{k}x^k
>   $$

<br>

生成函数的一个非常重要的作用就是可以用于解决计数问题，例如对于之前讨论过的当元素允许重复是 $n$ 元素集合的 $r$ 组合数公式：

设 $G(x)$ 是关于序列 $$ \{a_r\} $$ 的生成函数，其中 $a_r$ 等于 $n$ 元素集合的允许重复的 $r$ 组合数。当构成允许重复的 $r$ 组合时，对 $n$ 元素集合的元素选择不受限制，所以这 $n$ 个元素中的每一个元素都对 $G(x)$ 贡献了因子 $1+x+x^2+\cdots$，因为集合中有 $n$ 个元素：

$$
    G(x)=(1+x+x^2+\cdots)^n=\frac{1}{(1-x)^n},\;\lvert x\rvert<1
$$

根据广义二项式定理，有

$$
    \frac{1}{(1-x)^n}=(1-x)^{-n}=\sum_{r=0}^\infty\binom{-n}{r}(-x)^r
$$

根据广义二项式系数，有

$$
    \begin{aligned}
        (-1)^r\binom{-n}{r}&=(-1)^r\frac{(-n)(-n-1)\cdots(-n-r+1)}{r!}\\
        &=(-1)^r\frac{(-1)^rn(n+1)\cdots(n+r-1)}{r!}\\
        &=\frac{(n+r-1)!}{r!(n-1)!}\\
        &=\binom{n+r-1}{r}
    \end{aligned}
$$

<br>

生成函数的另一个重要作用是用于求解递推关系：设一个有效的码字是一个包含偶数个 $0$ 的十进制数字串，令 $a_n$ 表示 $n$ 位有效码字的个数。

首先我们需要给出这个问题的递推关系。对于 $n-1$ 位有效码字，我们可以在末尾添加一位非零数字来得到 $n$ 位有效码字，这样的方法有 $9a_{n-1}$ 种；对于 $n-1$ 位无效码字，我们可以在末尾添加一个 $0$ 来得到 $n$ 位有效码字，这样的方法有 $10^{n-1}-a_{n-1}$ 种，因此

$$
    a_n=8a_{n-1}+10^{n-1}
$$

设 $G(x)$ 是 $a_n$ 的生成函数，初始条件是 $a_1=9$，为了能进行生成函数的分析，根据递推关系我们可以得到 $a_0=1$，上述式子两边同时乘以 $x^n$ 得到：

$$
    a_nx^n=8a_{n-1}x^n+10^{n-1}x^n
$$

两边同时从 $1$ 开始做无穷级数求和：

$$
    \begin{aligned}
        G(x)-1&=\sum_{n=1}^\infty a_nx^n=\sum_{n=1}^\infty(8a_{n-1}x^n+10^{n-1}x^n)\\
        &=8\sum_{n=1}^\infty a_{n-1}x^n+\sum_{n=1}^\infty 10^{n-1}x^n\\
        &=8x\sum_{n=0}^\infty a_nx^n+x\sum_{n=0}^\infty (10x)^n\\
        &=8xG(x)+\frac{x}{1-10x}
    \end{aligned}
$$

由以上可得 $G(x)$ 的表示式及其生成函数：

$$
    \begin{aligned}
        G(x)&=\frac{1-9x}{(1-10x)(1-8x)}\\
        &=\frac{1}{2}\left(\frac{1}{1-10x}+\frac{1}{1-8x}\right)\\
        &=\frac{1}{2}\left(\sum_{n=0}^\infty 10^nx^n+\sum_{n=0}^\infty 8^nx^n\right)\\
        &=\sum_{n=0}^\infty\frac{1}{2}(8^n+10^n)x^n
    \end{aligned}
$$

因此根据以上分析可得 $\displaystyle a_n=\frac{1}{2}(8^n+10^n)$。

<br>

<br>

<br>

## 3 关系

<br>

### 3.1 关系及其性质

<br>

> **定义 3.1-1 集合的关系**
>
> 设 $A$ 和 $B$ 是集合，一个从 $A$ 到 $B$ 的二元关系是 Cartesian 积 $A\times B$ 的一个子集。即这个二元关系是一个集合 $R$，其中每个有序对的第一个元素取自 $A$ 而第二个元素取自 $B$。我们使用记号 $aRb$ 表示 $(a,b)\in R$，用 $a\cancel{R}b$ 表示 $(a,b)\notin R$

<br>

> **定义 3.1-2 集合上的关系**
>
> 集合 $A$ 上的关系是从 $A$ 到 $A$ 的关系，即是 Cartesian 积 $A\times A$ 的子集

<br>

对于 $n$ 元素集合 $A$，$A\times A$ 总共有 $n^2$ 个有序对，因此定义在 $n$ 元素集合上总共有 $2^{n^2}$ 个关系。

<br>

> **定义 3.1-3 自反性**
>
> 若对每个元素 $a\in A$ 有 $(a,a)\in R$，那么定义在集合 $A$ 上的关系 $R$ 是自反的（reflexive）；若对每个元素 $a\in A$ 有 $(a,a)\notin R$，那么定义在集合 $A$ 上的关系 $R$ 是反自反的（antireflexive）

<br>

对于 $n$ 元素集，如果定义在其上的关系 $R$ 是自反的，对于任意元素 $a\in A$，有序对 $(a,a)$ 一定在 $R$ 中。对于 $(a,b)$ 其中 $a\neq b$ 这样形式的有序对，总共有 $n(n-1)$ 个，它们可能在 $R$ 中也有可能不在，根据乘法原理可知一共存在 $2^{n(n-1)}$ 个自反的关系。反自反关系的计数过程和此类似，其个数也是 $2^{n(n-1)}$。

<br>

> **定义 3.1-4 对称性**
>
> 对于任意 $a,b\in A$，若只要 $(a,b)\in R$ 就有 $(b,a)\in R$，则称定义在集合 $A$ 上的关系 $R$ 是对称的（symmetric）。若对于任意 $a,b\in A$，若 $(a,b)\in R$ 且 $(b,a)\in R$，则一定有 $a=b$，则称定义在集合 $A$ 上的关系 $R$ 为反对称的（antisymmetric）

<br>

对于 $n$ 元素集，对称的有序对 $(a,b),(b,a)$，其中 $a\neq b$ 总共有 $\displaystyle\frac{n(n-1)}{2}$ 个，对于 $a=b$ 的自反有序对有 $n$ 个，因此所有的对称有序对有 $\displaystyle\frac{n(n+1)}{2}$ 个，对称关系总共有 $2^{n(n+1)/2}$ 个。

反对称不是对称的反义，对于只有 $(a,a)$ 的关系，它既是对称又是反对称的。我们来考虑反对称关系的个数，我们将 $n\times n$ 的所有关系表示成如下的矩阵（在之后会讲到矩阵表示关系的方法）：

$$
    \begin{pmatrix}
        1(0)& & & & \\
         &1(0)& & * & \\
         & & \ddots & & \\
         &* & & 1(0) &\\
         & & & & 1(0)\\
    \end{pmatrix}_{n\times n}
$$

只要选择了上三角中的某个有序对，就不能选择它对称处的有序对，对角线上的有序对不受影响，它们可出现在 $R$ 中也可不出现在 $R$ 中，总共有 $2^n$ 种选择。对于上三角和下三角的选择，设上三角和下三角元素的个数为 $\displaystyle r=\frac{n(n-1)}{2}$，我们可以得到

$$
    \begin{aligned}
        &\binom{r}{0}\sum_{j=0}^r\binom{r}{j}+\binom{r}{1}\sum_{j=0}^{r-1}\binom{r-1}{j}+\cdots+\binom{r}{r}\\
        &=\binom{r}{0}2^r+\binom{r}{1}2^{r-1}+\cdots+\binom{r}{r}2^0\\
        &=(1+2)^r\\
        &=3^{n(n-1)/2}
    \end{aligned}
$$

综上所述，反对称关系总共有 $2^n\times 3^{n(n-1)/2}$ 种。

<br>

> **定义 3.1-5 传递性**
>
> 对于任意 $a,b,c\in A$，$(a,b)\in R$ 并且 $(b,c)\in R$ 则 $(a,c)\in R$，那么定义在集合 $A$ 上的关系 $R$ 称为传递的（transitive）

<br>

$n$ 元素集的满足传递性的关系个数暂时没有发现闭公式，截止 2024-03-29，只给出了 $0\leq n\leq 18$ 时的关系数，具体可见 [OEIS-A006905](https://oeis.org/A006905)。

<br>

由于关系实际就是有序对的集合，因此关系之间也同样有集合间的运算。关系还具有一种合成运算，与映射的复合运算相似：

<br>

> **定义 3.1-6 关系的合成**
>
> 设 $R$ 是从集合 $A$ 到集合 $B$ 的关系，$S$ 是从集合 $B$ 到集合 $C$ 的关系。$R$ 与 $S$ 的合成是由有序对 $(a,c)$ 的集合构成的关系，其中 $a\in A,c\in C$，并且存在一个 $b\in B$ 的元素，使得 $(a,b)\in R$ 并且 $(b,c)\in R$。用 $S\circ R$ 表示 $R$ 与 $S$ 的合成

<br>

> **定义 3.1-7 关系的自身合成**
>
> 设 $R$ 是集合 $A$ 上的关系。 $R$ 的 $n$ 次幂 $R^n(n=1,\cdots,n)$ 递归地定义为
>
> $$
    R^1=R,\; R^{n+1}=R^n\circ R
>   $$

<br>

> **命题 3.1-1 传递关系的幂是该关系的子集**
>
> 设集合 $A$ 上的关系 $R$ 是传递的，当且仅当对 $n=1,2，3，\cdots$ 有 $R^n\subseteq R$

<br>

证明：
- 充分性：假设对 $n=1,2,3,\cdots$ 有 $R^n\subseteq R$，特别地有 $R^2\subseteq R$。注意若 $(a,b)\in R$ 且 $(b,c)\in R$，则 $(a,c)\in R^2$，因为 $R^2\subseteq R$，故 $(a,c)\in R$，于是 $R$ 具有传递性；
- 必要性：使用归纳法证明，当 $n=1$ 时命题成立；假设 $R^n\subseteq R$，其中 $n$ 是正整数；假设 $(a,b)\in R^{n+1}$，则因为 $R^{n+1}=R^n\circ R$，所以存在元素 $x\in A$ 使得 $(a,x)\in R$，$(x,b)\in R^n$，根据归纳假设知 $(x,b)\in R$，由传递性知 $(a,b)\in R$，因此 $R^{n+1}\subseteq R$。

<br>

### 3.2 关系的表示

<br>

可以用 $0/1$ 矩阵表示一个有穷集之间的关系，设 $R$ 是从 $$ A=\{a_1,\cdots,a_m\} $$ 到 $$ B=\{b_1,\cdots,b_n\} $$ 的关系，关系 $R$ 可以用矩阵 $$ \mathbf{M}_R=\left[m_{ij}\right] $$ 来表示：

$$
    m_{ij}=\begin{cases}
        1&(a_i,b_j)\in R\\
        0&(a_i,b_j)\notin R
    \end{cases}
$$

当 $a_i,b_j$ 有关系时表示 $R$ 的 $0/1$ 矩阵的 $(i,j)$ 项为 $1$，无关系表示为 $0$，我们很容易得到以下结论：
- 如果 $R$ 是自反的，则 $\mathbf{M}_R$ 的主对角线上的元素全为 $1$，非主对角线元素可以为 $0$，也可以为 $1$，即

    $$
        \mathbf{M}_R=\begin{pmatrix}
            1 &   &   &   &   \\
              & 1 &   & * &   \\
              &   & \ddots &   & \\
              & * &   & 1 &   \\
              &   &   &   & 1 \\
        \end{pmatrix}
    $$

- 如果 $R$ 是对称的，则 $\mathbf{M}_R$ 中 $$ m_{ij}=m_{ji}$$，即满足

    $$
        \mathbf{M}_R=(\mathbf{M}_R)^\mathrm{T}
    $$

- 如果 $R$ 是反对称的，则 $\mathbf{M}_R$ 中 $$ m_{ij}\neq m_{j,i}$$，其中 $i\neq j$。

<br>

> **定义 3.2-1 布尔运算**
>
> 令 $\mathbf{A}=\left[a_{ij}\right]$ 与 $\mathbf{B}=\left[b_{ij}\right]$ 为 $m\times n$ 的 $0/1$ 矩阵，它们的布尔交（Boolean meet）运算定义如下：
>
> $$
    b_1\wedge b_2=\begin{cases}
        1& b_1,b_2=1\\
        0& \text{other}\;\text{situations}
    \end{cases}
>   $$
>
> 则 $\mathbf{A}\wedge\mathbf{B}$ 是 $0/1$ 矩阵，其中元素 $(i,j)$ 为 $a_{ij}\wedge b_{ij}$；
>
> 它们的布尔并（Boolean join）运算定义如下：
>
> $$
    b_1\vee b_2=\begin{cases}
        1&b_1=1\;\text{or}\;b_2=1\\
        0&\text{other}\;\text{situations}
    \end{cases}
>   $$
>
> 则 $\mathbf{A}\vee\mathbf{B}$ 是 $0/1$ 矩阵，其中元素 $(i,j)$ 为 $a_{ij}\vee b_{i,j}$；
>
> 令 $\mathbf{C}=\left[c_{ij}\right]$ 为 $m\times n$ 的 $0/1$ 矩阵，$\mathbf{D}=\left[d_{ij}\right]$ 为 $n\times p$ 的 $0/1$ 矩阵。$\mathbf{C}$ 与 $\mathbf{D}$ 的布尔积（Boolean product）记作 $\mathbf{C}\odot\mathbf{D}$，是 $m\times p$ 矩阵 $\left[e_{ij}\right]$，其中
>
> $$
    e_{ij}=\bigvee_{k=1}^nc_{ik}\wedge d_{kj}
>   $$
>
> 布尔积运算与矩阵乘法类似，但是需要用 $\vee$ 代替 $+$，用 $\wedge$ 代替 $\times$。

<br>

根据 $0/1$ 矩阵的布尔运算，我们很容易可以得到以下结论：

$$
    \mathbf{M}_{R_1\cup R_2}=\mathbf{M}_{R_1}\vee\mathbf{M}_{R_2},\quad\mathbf{M}_{R_1\cap R_2}=\mathbf{M}_{R_1}\wedge\mathbf{M}_{R_2}
$$

我们考虑关系合成的 $0/1$ 矩阵表示，设关系 $R$ 和 $S$，记 $S\circ R$、$R$ 与 $S$ 对应的 $0/1$ 矩阵为 $$ \mathbf{M}_{S\circ R}=\left[t_{ij}\right] $$、$$ \mathbf{M}_R=\left[r_{ij}\right] $$ 与 $$ \mathbf{M}_S=\left[s_{ij}\right] $$，其中 $R$ 对应 $m\times n$ 矩阵，$S$ 对应 $n\times p$ 矩阵。有序对 $(a_i,c_j)\in R\circ S$ 当且仅当存在元素 $b_k$ 使得 $(a_i,b_k)\in R$ 且 $(b_k,c_j)\in S$，根据这样的定义我们可以得到：

$$
    \mathbf{M}_{S\circ R}=\mathbf{M}_R\odot\mathbf{M}_S
$$

<br>

除了使用 $0/1$ 矩阵描述集合的关系，还可以使用图来描述集合。把集合中的每一个元素表示成一个点，每个有序对表示成点之间带有箭头的弧线，弧线上的箭头标明了弧的方向。我们可以将有限集上的关系看作有向图。

<br>

> **定义 3.2-2 有向图**
>
> 一个有向图（directed graph/digraph）由顶点集（vertices）$V$ 及边集（edges）$E$ 组成，其中边集 $E$ 是 $V$ 中元素的有序对的集合。顶点 $a$ 叫做边 $(a,b)$ 的始点，顶点 $b$ 叫做这条边的终点。形如 $(a,a)$ 的边用一条从顶点 $a$ 到自身的弧表示，这种边叫做**环**

<br>

一个图的例子如下：

<br>

![图 3.2-1：图](/figure/Screenshot 2024-05-05 154158.png)

<br>

观察有向图我们很容易就能给出这些结论：
- 一个关系是自反的，当且仅当表示关系的有向图每个顶点都有环；
- 一个关系是对称的，当且仅当表示关系的有向图中每个边都有一个相反的边（事实上，对称关系可以使用无向图进行研究，无向图中边没有方向）；
- 一个关系是反对称的，当且仅当在两个不同的顶点之间不存在两条方向相反的边；
- 一个关系是传递的，当且仅当只要存在一条从顶点 $x$ 到顶点 $y$ 的边和一条从顶点 $y$ 到 $z$ 的边，就有一条从顶点 $x$ 到顶点 $z$ 的边。

<br>

### 3.3 关系的闭包

<br>

> **定义 3.3-1 闭包**
>
> 设 $R$ 是集合 $A$ 上的关系，若存在关系 $R$ 的具有性质 $P$ 的闭包（closure），则此闭包是集合 $A$ 上包含 $R$ 的具有性质 $P$ 的关系 $S$，并且 $S$ 是每一个包含 $R$ 的具有性质 $P$ 的 $A\times A$ 的子集

<br>

- 自反闭包：对于集合 $A$ 上的关系 $R$，其最小的自反闭包定义如下

    $$
        R\cup\Delta=R\cup\{(a,a):a\in A\}
    $$

- 对称闭包：根据映射的逆映射，我们也可以定义一个逆关系。设关系 $R$ 是从 $A$ 到 $B$ 的关系，定义为 $$ R=\{(a,b):a\in A,b\in B\} $$，则其逆关系 $R^{-1}$ 是从 $B$ 到 $A$ 的关系，定义为 $$ R^{-1}=\{(b,a):(a,b)\in R\} $$。关系 $R$ 的最小对称闭包定义如下

    $$
        R\cup R^{-1}=R\cup\{(b,a):(a,b)\in R\}
    $$

<br>

#### 3.3.1 传递闭包与连通性关系

<br>

我们也可以利用有向图来研究闭包，首先我们要定义路径：

<br>

> **定义 3.3-2 路径**
>
> 在有向图 $G$ 中，从 $a$ 到 $b$ 的一条路径（path）是图 $G$ 中一条或者多条边的序列 $(x_0,x_1),(x_1,x_2),\cdots,(x_{n-1},x_n)$，其中 $n$ 是一个非负整数，$x_0=a,x_n=b$，即一个边的序列，其中一条边的终点和路径中下一条边的始点相同。这一条路径记作 $x_0,x_1,\cdots,x_n$，长度为 $n$。我们把一个为空的边的集合看作从 $a$ 到 $a$ 的长度为 $0$ 的路径。在同一顶点开始或者结束的长度 $n\geq 1$ 的路径，称为回路（circuit）或者圈（circle）

<br>

例如前面例子中的有向图从`a`到`d`的路径有`a->d`和`a->b->d`，前者是长度为 $1$ 的路径，后者是长度为 $2$ 的路径。根据有向图中路径的定义，我们可以得到以下命题：

<br>

> **命题 3.3-1 路径与自身复合的关系**
>
> 设 $R$ 是集合 $A$ 上的关系，从 $a$ 到 $b$ 存在一条长为 $n$ 的路径，当且仅当 $(a,b)\in R^n$

<br>

证明：使用数学归纳法。从 $a$ 到 $b$ 存在一条长为 $1$ 的路径，当且仅当 $(a,b)\in R$。假设对于正整数 $n$，命题为真。若存在从 $a$ 到 $b$ 的长度为 $n+1$ 的路径，根据归纳假设，存在元素 $c\in A$ 使得存在从 $a$ 到 $c$ 的长度为 $1$ 的路径，且存在从 $c$ 到 $b$ 的长度为 $n$ 的路径，它们分别满足 $(a,c)\in R$ 与 $(c,b)\in R^n$，因此 $(a,b)\in R^{n+1}$；若 $(a,b)\in R^{n+1}$，分析相同。综上可以得到命题成立。

<br>

> **定义 3.3-3 连通性关系**
>
> 设 $R$ 是集合 $A$ 上的关系，连通性关系 $$ R^* $$ 由形如 $(a,b)$ 的有序对构成，使得在关系 $R$ 中，从顶点 $a$ 到 $b$ 之间存在一条长度至少为 $1$ 的路径。即 $$ R^* $$ 是所有 $R^n$ 的并集：
>
> $$
    R^*=\bigcup_{n=1}^\infty R^n
>   $$

<br>

> **命题 3.3-2 传递闭包与连通性关系**
>
> 关系 $R$ 的传递闭包等于连通性关系 $$ R^* $$

<br>

证明：为证明 $$ R^* $$ 是 $R$ 的传递闭包，我们必须证明 $$ R^* $$ 是传递的并对一切包含 $R$ 的传递关系 $S$，有 $$ R^*\subseteq S $$。
- 首先证明 $$ R^* $$ 的传递性，如果 $$ (a,b)\in R^* $$ 且 $$ (b,c)\in R^* $$，那么在 $R$ 中存在从 $a$ 到 $b$ 和从 $b$ 到 $c$ 的路径，则我们可以构造一个 $a,b,c$ 的路径，因此 $$ (a,c)\in R^* $$，这就可以得到 $$ R^* $$ 是传递的；
- 其次假设 $S$ 是包含 $R$ 的传递关系，因为 $S$ 是传递的，所以 $S^n$ 也是传递的，并且 $S^n\subseteq S$。因为

    $$
        S^*=\bigcup_{k=1}^\infty S^k
    $$

    由于 $S^k\subseteq S$，因此 $$ S^* \subseteq S $$。因为 $R\subseteq S$，于是 $$ R^* \subseteq S^*\subseteq S $$，于是任何包含 $R$ 的传递关系也一定包含 $$ R^* $$，因此 $$ R^* $$ 就是最小的传递闭包。

<br>

> **命题 3.3-3 路径长度的最大性**
>
> 设 $A$ 是含有 $n$ 个元素的集合，$R$ 是集合 $A$ 上的关系。如果 $R$ 中存在一个一条从 $a$ 到 $b$ 的长度至少为 $1$ 的路径，那么这两点间存在一条不超过 $n$ 的路径。若 $a\neq b$，如果在两点间存在一条长度至少为 $1$ 的路径，那么这两点间存在一条不超过 $n-1$ 的路径

<br>

证明：假设 $R$ 中存在从 $a$ 到 $b$ 的路径，令 $m$ 是其中最短路径的长度。假设 $x_0,\cdots,x_m$ 是这样一条路径，其中 $x_0=a$，$x_m=b$。
- 假设 $a=b$ 且 $m>n$，可以得到 $m\geq n+1$，根据鸽巢原理知在 $x_0,\cdots,x_{m-1}$ 这 $m$ 个节点中至少有两个重复的节点。假设 $x_i=x_j$，其中 $1\leq i<j\leq m-1$，这就形成了一个回路，我们可以将该回路从路径中删除。如果剩下的路径长度依然大于 $n$，我们可以重复执行这个操作直到最短路径的长度小于等于 $n$；
- 假设 $a\neq b$ 且 $m>n-1$，可以得到 $m\geq n$，根据鸽巢原理知 $x_0,\cdots,x_m$ 这 $m+1$ 个节点中至少有两个重复的节点，根据同样的分析知最短路径的长度小于等于 $n-1$。

<br>

根据这个命题，我们知道在一个有限的有向图中，确定两个顶点之间是否存在一条路径不需要检测任意长的路径。则 $R^*=\bigcup_{i=1}^n R^i$，上标不再需要是 $\infty$ 了，故我们有以下算法：

<br>

> **算法 3.3-1 传递闭包的矩阵**
>
> 设 $\mathbf{M}_R$ 是定义在 $n$ 个元素集合上的关系 $R$ 的 $0/1$ 矩阵，那么传递闭包 $$ R^* $$ 的 $0/1$ 矩阵是
>
> $$
    \mathbf{M}_{R^*}=\mathbf{M}_R\vee\mathbf{M}_R^{\left[2\right]}\vee\cdots\vee\mathbf{M}_R^{\left[n\right]}
>   $$
>
> 算法如下：
>
> ``` pseudocode
> procedure | transitive closure
> A, M_R , B are all matrices
> 
> A := M_R
> B := A
> for i := 2 to n
>     A := BOOLEAN_PRODUCT(A, M_R)
>     B := BOOLEAN_JOIN(B, A)
> return B
> ```

<br>

以下是一个简单的用C++写的求解传递闭包的程序：

<br>

``` cpp
#include <iostream>
#include <string>

const int n = 4;
void booleanJoin(int m1[][n], int m2[][n]);
void booleanProduct(int m1[][n], int m2[][n]);

int main() {
    int MR[n][n] = {
        {0, 0, 0, 1},
        {0, 1, 0, 0},
        {0, 1, 0, 0},
        {1, 0, 1, 0}
    };
    int A[n][n];
    int B[n][n];
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            A[i - 1][j - 1] = MR[i - 1][j - 1];
            B[i - 1][j - 1] = MR[i - 1][j - 1];
        }
    }
    for (int k = 2; k <= n; k++) {
        booleanProduct(A, MR);
        booleanJoin(B, A);
    }
    std::string tempStr = "";
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            tempStr += (std::to_string(B[i - 1][j - 1]) + " ");
        }
        tempStr += "\n";
    }
    std::cout << tempStr;
    return 0;
}

void booleanJoin(int m1[][n], int m2[][n]) {
    for (int i = 1;i <= n; i++) {
        for (int j = 1; j<= n; j++) {
            if (m1[i - 1][j - 1] == 1
             || m2[i - 1][j - 1] == 1) {
                m1[i - 1][j - 1] = 1;
            }
            else {
                m1[i - 1][j - 1] = 0;
            }
        }
    }
}

void booleanProduct(int m1[][n],int m2[][n]) {
    int temp[n][n];
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            temp[i - 1][j - 1] = 0;
            for (int k = 1; k <= n; k++) {
                if (m1[i - 1][k - 1] == 1
                 && m2[k - 1][j - 1] == 1) {
                    temp[i - 1][j - 1] = 1;
                    break;
                }
            }
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            m1[i - 1][j - 1] = temp[i - 1][j - 1];
        }
    }
}
```

<br>

#### 3.3.2 Warshall 算法

<br>

首先定义内部顶点的概念：如果 $a,x_1,\cdots,x_{m-1},b$ 是一条路径，则 $x_1,\cdots,x_{m-1}$ 称为它的内部顶点。Warshall 算法构造一系列的 $0/1$ 矩阵 $$ \mathbf{W}_0,\cdots,\mathbf{W}_n $$，其中 $$ \mathbf{W}_0=\mathbf{M}_R $$ 是这个关系的 $0/1$ 矩阵，$$ \mathbf{W}_k=\left[w_{ij}^{(k)}\right] $$。如果存在一条从 $v_i$ 到 $v_j$ 的路径使得这条路径的所有内部顶点都在集合 $$ \{v_1,\cdots,v_k\} $$ （即表中的前 $k$ 个顶点），那么 $w_{ij}^{(k)}=1$。根据这样的构造方法可以知道 $$ \mathbf{W}_n $$ 就是传递闭包，因为 $w_{ij}^{(n)}$ 代表了在有向图中存在从 $v_i$ 到 $v_j$ 的路径。

<br>

可以直接通过 $$ \mathbf{W}_{k-1} $$ 计算 $$ \mathbf{W}_k $$，存在一条从 $v_i$ 到 $v_j$ 的只以 $v_1,\cdots,v_k$ 中的顶点为内部顶点的路径，当且仅当要么存在一条从 $v_i$ 到 $v_j$ 的且内部顶点是列表中前 $k-1$ 个顶点的路径，要么存在从 $v_i$ 到 $v_k$ 的路径和从 $v_k$ 到 $v_j$ 的路径，因此我们可以得到以下命题：

<br>

> **命题 3.3-4 Warshall 算法原理**
>
> 设 $$ \mathbf{W}_k=\left[w_{ij}^{(k)}\right] $$ 是 $0/1$ 矩阵，它的 $(i,j)$ 位置为 $1$ 当且仅当存在一条从 $v_i$ 到 $v_j$ 的路径，其内部顶点取自集合 $$ \{v_1,\cdots,v_k\} $$，那么
>
> $$
    w_{ij}^{(k)}=w_{ij}^{(k-1)}\vee\left(w_{ik}^{(k-1)}\wedge w_{kj}^{(k-1)}\right)
>   $$

<br>

> **算法 3.3-2 Warshall 算法**
>
> ``` pseudocode
> procedure | Warshall
> M_R, W are n times n 0/1 matrices
> 
> W := M_R
> for k := 1 to n
>     for i := 1 to n
>         for j := 1 to n
>             w_{ij} := BOOLEAN_JOIN(w_{ij}, BOOLEAN_MEET(w_{ik}, w_{kj}))
> return W
> ```
>
> 解释一下为什么这个算法需要从 $k=1$ 开始不断往后补全，这是因为传递关系比较复杂，在 Warshall 算法中每一次进行补全就会多出几条路径，这些路径就可能会产生新的路径，所以需要不断执行到 $k=n$ 才能停止

<br>

以下是使用C++写的 Warshall 算法的简单程序：

<br>

``` cpp
#include <iostream>
#include <string>

const int n = 4;
int booleanJoin(int a, int b);
int booleanMeet(int a, int b);

int main() {
    int MR[n][n] = {
        {0, 0, 0, 1},
        {1, 0, 1, 0},
        {1, 0, 0, 1},
        {0, 0, 1, 0}
    };
    int W[n][n];
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            W[i - 1][j - 1] = MR[i - 1][j - 1];
        }
    }
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                W[i - 1][j - 1] = booleanJoin(W[i - 1][j - 1], 
                booleanMeet(W[i - 1][k - 1], W[k - 1][j - 1]));
            }
        }
    }
    std::string tempStr = "";
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            tempStr += (std::to_string(W[i - 1][j - 1]) + " ");
        }
        tempStr += "\n";
    }
    std::cout << tempStr;
    return 0;
}

int booleanJoin(int a, int b) {
    return (a == 0 && b == 0) ? 0 : 1;
}

int booleanMeet(int a, int b) {
    return a * b;
}
```

<br>

### 3.4 等价关系

<br>

> **定义 3.4-1 等价关系**
>
> 如果定义在集合 $A$ 上的关系是自反的、对称的和传递的，那么称它为定义在集合 $A$ 上的等价关系（equivalence relations）。如果两个元素 $a$ 和 $b$ 由于等价关系而相关联，则称它们是等价的，记作 $a\sim b$

<br>

一个常见的例子是模 $m$ 同余是定义在整数集上的等价关系：

$$
    R=\{(a,b):a\equiv b\;(\text{mod}\;m)\}
$$

注意到 $a\equiv b\;(\text{mod}\;m)$ 当且仅当 $m$ 整除 $a-b$。注意 $a-a=0$ 能被 $m$ 整除，因此 $a\equiv a\;(\text{mod}\;m)$，模 $m$ 同余关系满足自反性；假设 $a\equiv b\;(\text{mod}\;m)$，则有 $a-b=km$ 成立，其中 $k$ 是整数，从而 $b-a=(-k)m$，因此也有 $b\equiv a\;(\text{mod}\;m)$，模 $m$ 同余关系满足对称性；假设 $a\equiv b\;(\text{mod}\;m)$ 和 $b\equiv c\;(\text{mod}\;m)$ 成立，则有 $a-b=k_1m$ 与 $b-c=k_2m$，因此

$$
    a-c=(a-b)+(b-c)=(k_1+k_2)m
$$

于是 $a\equiv c\;(\text{mod}\;m)$，模 $m$ 同余关系满足传递性。综上所述，模 $m$ 同余关系是等价关系。

<br>

> **定义 3.4-2 等价类**
>
> 设 $R$ 是定义在集合 $A$ 上的等价关系。与 $A$ 中的一个元素 $a$ 有关系 $R$ 的所有元素的集合叫做 $a$ 的等价类（equivalence classes）。$A$ 的关于 $R$ 的等价类记作 $\left[a\right]_R$。当只考虑一个关系时，一般省去下标并写作 $\left[a\right]$

<br>

如果关系 $R$ 是定义在集合 $A$ 上的等价关系，则元素 $a$ 的等价类是：

$$
    \left[a\right]_R=\{s:(a,s)\in R\}
$$

如果 $b\in\left[a\right]_R$，则称 $b$ 是这个等价类的代表元（representative），一个等价类的任何元素都可以作为这个类的代表元，选择特定元素作为一个类的代表元没有特殊要求。

<br>

> **命题 3.4-1 等价类与划分**
>
> 设 $R$ 是定义在集合 $A$ 上的等价关系，下面关于集合 $A$ 中 $a,b$ 两个元素的命题是等价的：
> - （a）$aRb$
> - （b）$\left[a\right]=\left[b\right]$
> - （c）$\left[a\right]\cap\left[b\right]\neq\emptyset$

<br>

证明：
- 首先证明（a）能推出（b）。当 $aRb$ 时，我们将通过证明 $\left[a\right]\subseteq\left[b\right]$ 与 $\left[a\right]\supseteq\left[b\right]$ 证明 $\left[a\right]=\left[b\right]$。如果 $c\in\left[a\right]$，则 $aRc$。因为 $R$ 是对称的，所以 $aRb$ 可以推出 $bRa$；因为 $R$ 是传递的，所以 $bRa$ 与 $aRc$ 可以推出 $bRc$，故 $c\in\left[b\right]$，因此 $\left[a\right]\subseteq\left[b\right]$，同理也可以推出 $\left[a\right]\supseteq\left[b\right]$；
- 接着证明（b）能推出（c）。注意到 $\left[a\right]$ 是非空的，因为 $R$ 具有自反性，有 $a\in\left[a\right]$，因此当 $\left[a\right]=\left[b\right]$ 时有 $\left[a\right]\cap\left[b\right]=\left[a\right]\neq\emptyset$；
- 最后证明（c）能推出（a）。当 $\left[a\right]\cap\left[b\right]\neq\emptyset$ 时，存在元素 $c\in\left[a\right]$ 且 $c\in\left[b\right]$，即 $aRc$ 且 $bRc$，由于 $R$ 具有对称性，则 $cRb$，并且 $R$ 具有传递性，因此 $aRb$。

以上命题说明了如果 $\left[a\right]\cap\left[b\right]=\emptyset$，则不可能有 $aRb$ 成立，我们可以根据这点对集合进行划分。设 $R$ 是定义在集合 $A$ 上的等价关系，注意到集合 $A$ 中的元素 $a$ 都在其等价类 $\left[a\right]_R$ 中（这是因为 $R$ 满足自反性），因此

$$
    \bigcup_{a\in A}\left[a\right]_R=A
$$

我们还有

$$
    \left[a\right]_R\neq\left[b\right]_R\Leftrightarrow\left[a\right]_R\cap\left[b\right]_R=\emptyset
$$

以上两个结论说明等价类构成 $A$ 的划分，它们将 $A$ 划分成不相交的子集。

<br>

反过来我们也可以用集合的每个划分来构成等价关系。假设 $A_1,\cdots,A_n$ 是集合 $S$ 的一个划分，设 $R$ 是 $S$ 上的由有序对 $(x,y)$ 组成的关系，其中 $x,y$ 属于这个划分的同一子集 $A_i$。我们注意到有以下三点成立：
- 自反性：对于每个元素 $a\in S$，$a,a$ 同属于一个子集 $A_i$，所以 $R$ 是自反的；
- 对称性：对于元素 $a$ 和 $b$ 同属于 $A_i$，我们知道元素 $b$ 和 $a$ 同属于 $A_i$，因此 $aRb$ 和 $bRa$ 可以相互推出，$R$ 是对称的；
- 传递性：对于元素 $a$ 和 $b$ 同属于 $A_i$，元素 $b$ 和 $c$ 同属于 $A_i$，我们知道元素 $a$ 和 $c$ 同属于 $A_i$，因此 $aRb\wedge bRc\Rightarrow aRc$，$R$ 是传递的。

综上所述，$R$ 是一个等价关系，$R$ 的等价类由 $S$ 的子集组成。

<br>

> **命题 3.4-2 等价类和集合划分的关系**
>
> 设 $R$ 是定义在集合 $S$ 上的等价关系，那么 $R$ 的等价类构成集合 $S$ 的划分。反过来，给定集合 $S$ 的划分 $A_1,\cdots,A_n$，则存在一个等价关系 $R$，它以集合 $A_i(i\in I)$（其中 $I$ 是一个指标集）作为它的等价类

<br>

### 3.5 偏序

<br>

#### 3.5.1 偏序等基础概念

<br>

> **定义 3.5-1 偏序**
>
> 定义在集合 $S$ 上的关系 $R$，如果它是自反的、反对称的、传递的，则称其为偏序的（partial orderings）。集合 $S$ 与定义在其上的偏序 $R$ 一起称为偏序集，记作 $(S,R)$

<br>

以下是一些偏序集的例子：$(\mathbb{Z},\leq)$，$(2^S,\subseteq)$。在不同的偏序集中会使用不同的符号来表示偏序，我们一般使用符号 $\preceq$ 来表示任意一个偏序集中的序关系，即在偏序集 $(S,R)$ 中 $a\preceq b$ 表示 $(a,b)\in R$，我们还可以使用 $a\prec b$ 表示 $a\preceq b$ 且 $a\neq b$。

<br>

> **定义 3.5-2 偏序元素的可比性**
>
> 偏序集 $(S,\preceq)$ 中的元素 $a$ 和 $b$ 称为可比的（comparable），如果 $a\preceq b$ 或者 $b\preceq a$。当元素 $a$ 和 $b$ 是 $S$ 中的元素不存在 $a\preceq b$ 和 $b\preceq a$ 这两个关系时，则称它们是不可比的（incomparable）

<br>

偏序上的元素不一定都是可以比较的，例如偏序集 $(2^{\mathbb{Z}},\subseteq)$ 中的元素 $$ \{1,2\} $$ 与 $$ \{1,3\} $$ 之间没有序上的关系。偏（partial）的意思是「部分的」，就是形容偏序集中有部分元素不可比较。

<br>

> **定义 3.5-3 全序集**
>
> 如果 $(S,\preceq)$ 是偏序集，且 $S$ 中的每个元素都是可比的，则 $S$ 称为全序集（total orderings set）或者线序集（linear orderings set），$\preceq$ 称为全序或者线序

<br>

> **定义 3.5-4 良序集**
>
> 对于偏序集 $(S,\preceq)$，如果 $\preceq$ 是全序，并且 $S$ 的每一个非空子集都有一个最小元素，则称它为良序集（well-ordered set）

<br>

良序集的一个例子如下：$(\mathbb{Z}^+\times\mathbb{Z}^+,\preceq)$，其中 $\preceq$ 表示字典顺序，即如果 $a_1<b_1$ 或者如果 $a_1=b_1$ 且 $a_2\leq b_2$，则 $(a_1,b_1)\preceq(a_2,b_2)$，这个集合的每一个子集都有最小元素。

<br>

非良序集的一个例子如下：$(\mathbb{Z},\leq)$，这是因为 $\mathbb{Z}$ 的子集可能没有最小元素，例如负整数集。

<br>

> **命题 3.5-1 良序归纳原理**
>
> 设 $S$ 是一个良序集，对所有 $y\in S$，如果 $P(x)$ 对所有 $x\in S$ 且 $x\prec y$，则 $P(y)$ 为真，那么 $P(x)$ 对所有 $x\in S$ 均为真

<br>

证明：假设 $P(x)$ 不对所有的 $x\in S$ 为真，那么存在一个元素 $y\in S$ 使得 $P(y)$ 为假，于是集合 $$ A=\{x\in S:P(x)\;\text{is}\;\text{false}\} $$ 是非空的。因为 $S$ 是一个良序集，所以集合 $A$ 作为 $S$ 的子集，有一个最小元素 $a$，那么对所有的 $x\in S$ 且 $x\prec a$ 都有 $P(x)$ 为真，根据归纳的步骤可知 $P(a)$ 为真，这与假设矛盾，因此 $P(x)$ 对所有 $x\in S$ 为真。

<br>

> **定义 3.5-5 字典顺序**
>
> 两个集合的 Cartesian 积上的字典顺序在前面已经给出了。我们定义在 $n$ 个偏序集 $(A_1,\preceq_1),\cdots,(A_n,\preceq_n)$ 的 Cartesian 积上的字典顺序（lexicographic order）是 $A_1\times\cdots\times A_n$ 上的偏序 $\preceq$：
>
> $$
    (a_1,\cdots,a_n)\prec(b_1,\cdots,b_n)
>   $$
>
> 如果 $a_1\prec_1b_1$，或者存在整数 $i>0$，使得 $a_1=b_1,\cdots,a_i=b_i$ 且 $a_{i+1}\prec_{i+1}b_{i+1}$

<br>

> **定义 3.5-6 Hasse 图**
>
> 对于一个有穷的偏序集 $(S,\preceq)$，从这个关系的有向图开始：由于偏序是自反的，所以在每一个顶点 $x$ 都有环 $(x,x)$，移除这些环；对于元素 $z\in S$ 如果 $x\prec z$ 且 $z\prec y$，则移除所有这样的边 $(x,y)$；排列每条边使得它的起点在终点的下面，移除有向边上所有的箭头。这些步骤是有明确定义的，并且对于一个有穷偏序集只需有限步执行，当所有的步骤执行以后，就得到一个包含足够的表示偏序的图，称为 Hasse 图

<br>

若在偏序集 $(S,\preceq)$ 中，不存在 $b\in S$ 使得 $a\prec b$，则 $a$ 在偏序集中是极大元；若不存在 $b\in S$ 使得 $b\prec a$，则 $a$ 在偏序集中是极小元。在 Hasse 图中很容易看出极大元和极小元，极大元位于图的「局部顶部」，极小元位于图的「局部底部」。若偏序集中存在一个元素大于每个其他的元素（即不存在不可比的情形），则称为最大元，类似的还有最小元的概念。

<br>

如果 $u\in S$，$A\subseteq S$ 且对所有元素 $a\in A$ 都有 $a\preceq u$，那么 $u$ 称为 $A$ 的上界，对于任意上界 $u$，若存在上界 $x$ 使得 $x\preceq u$，那么 $x$ 称为 $A$ 的最小上界；下界和最大下界的概念是类似的。最小上界记为 $\text{lub}(A)$，最大下界记为 $\text{glb}(A)$。

<br>

> **定义 3.5-7 格**
>
> 如果一个偏序集的每对元素都有最小上界和最大下界，则称这个偏序集为格（lattice）

<br>

格的例子：$(\mathbb{Z}^+,\mid)$，对于一对元素 $(a,b)$，它们的最小上界是最小公倍数，最大下界是最大公约数；$(2^S,\subseteq)$，对于任意两个子集 $A$ 和 $B$，它们的最小上界是 $A\cup B$，最大下界是 $A\cap B$。

<br>

#### 3.5.2 拓扑排序

<br>

> **命题 3.5-2**
>
> 每个有穷非空偏序集 $(S,\preceq)$ 至少有一个极小元

<br>

证明是相对容易的：选择 $S$ 中的一个元素 $a_0$，如果 $a_0$ 不是极小元，则存在元素 $a_1\prec a_0$；如果 $a_1$ 不是极小元，则存在元素 $a_2\prec a_1$，以此类推。因为 $S$ 是有穷的，所以这一操作会最终停下来，最终得到的元素即为极小元。

<br>

> **算法 3.5-1 拓扑排序**
>
> 考虑一个实际问题：有一个项目由 $n$ 个任务组成，某些任务只能在其他任务结束之后完成，如何找到关于这些任务的顺序？我们在任务的集合上构造一个偏序，使得 $a\prec b$ 当且仅当 $a$ 和 $b$ 是任务且直到 $a$ 结束后 $b$ 才能开始。如果只要 $aRb$ 就有 $a\preceq b$，则称一个全序 $\preceq$ 与偏序 $R$ 是相容的，从一个偏序中构造相容的全序的算法称为拓扑排序。
>
> 为了在偏序集 $(A,\preceq)$ 上定义一个全序，首先选择一个极小元 $a_1$，由于移除极小元剩下的集合 $$ (A-\{a_1\},\preceq) $$ 仍然是一个偏序集（不影响其余元素的自反性、传递性和反对称性），当其不是空集时我们仍然可以选取极小元 $a_2$，然后移除它，以此类推。因为 $A$ 是有穷的，这一操作最终会停下来，产生一个元素序列 $a_1,\cdots,a_n$，而所需要的全序 $\preceq_t$ 满足
>
> $$
    a_1\prec_t a_2\prec_t\cdots\prec_t a_n
>   $$
>
> 这样得到的顺序就是满足题意的做任务的顺序。其伪代码如下：
>
> ``` pseudocode
> procedure | topological sort
> 
> k := 1
> while (S != EMPTY_SET)
>     a_k := Minimal Element Of S
>     S := S - {a_k}
>     k := k + 1
> return a_1,...,a_n
> ```

<!-- TODO : 这里给出的拓扑排序的伪代码实际难以转化为程序代码，待我学习了算法基础再来学习如何实现拓扑排序 -->

<br>

<br>

<br>

## 4 图

<br>

### 4.1 图的基本概念

<br>

#### 4.1.1 图的分类

<br>

> **定义 4.1-1 图**
>
> 图（graph）$G=(V,E)$ 由顶点的非空集 $V$ 和边集 $E$ 构成，每条边有一个或者两个顶点与它相连，这样的顶点称为边的端点。顶点集为无限集或者边集为无限集的图称为无限图，顶点集和边集为有限集的图称为有限图

<br>

> **定义 4.1-2 有向图**
>
> 有向图 $G=(V,E)$ 由一个非空顶点集 $V$ 和一个有向边集 $E$ 组成，每条有向边和一个顶点有序对相关联，我们称与有序对 $(u,v)$ 相关联的有向边开始于 $u$，结束于 $v$

<br>

|图|边|允许多重边|允许环|
|:---:|:---:|:---:|:---:|
|简单无向图（simple undirected graph）|无向|否|否|
|多重无向图（undirected multigraph）|无向|是|否|
|伪图（pseudograph）|无向|是|是|
|简单有向图（simple directed graph）|有向|否|否|
|多重有向图（directed multigraph）|有向|是|是|
|混合图（mixed graph）|有向和无向都有|是|是|

<br>

#### 4.1.2 图的术语

<br>

> **定义 4.1-3 相邻**
>
> 若 $u$ 和 $v$ 是无向图 $G$ 中的一条边 $e$ 的端点，则称两个顶点 $u$ 和 $v$ 在 $G$ 中相邻（邻接），这样的边 $e$ 称为关联顶点 $u$ 和 $v$，也可以说 $e$ 连接 $u$ 和 $v$

<br>

> **定义 4.1-4 邻居**
>
> 图 $G=(V,E)$ 中，顶点 $v$ 的所有相邻顶点的集合，记作 $N(v)$，称为顶点 $v$ 的邻居。若 $A$ 是 $V$ 的子集，我们用 $N(A)$ 表示图 $G$ 中至少和 $A$ 中一个顶点相邻的所有顶点的集合，即
>
> $$
    N(A)=\bigcup_{v\in A}N(v)
>   $$

<br>

> **定义 4.1-5 度**
>
> 在无向图中，顶点的度是与该顶相关联的边的数目，例外的情形是，顶点上的环为顶点的度做出了双倍的贡献，顶点的度表示为 $\deg v$

<br>

我们经常称度为 $0$ 的顶点是孤立的，孤立点不与任何顶点相邻。称度为 $1$ 的顶点是悬挂的，悬挂点恰与一个顶点相邻。称度为奇数的顶点是奇点，度为偶数的顶点是偶点。

<br>

对于一张图，所有顶点的度数的最小值称为最小度，记为 $\delta(G)$，最大值称为最大度，记为 $\Delta(G)$，即

$$
    \delta(G)=\min_{v\in G}\deg v,\quad\Delta(G)=\max_{v\in G}\deg v
$$

<br>

> **命题 4.1-1 图论基本定理**
>
> 设 $G=(V,E)$ 是有 $m$ 条边的无向图，则
>
> $$
    2m=\sum_{v\in V}\deg v
>   $$
>
> 每条边都连接了两个顶点，因此为整个无向图的度之和提供了 $2$，这个情形也可以类比握手必须有两只手参与的情形，所以这个定理又称为握手定理

<br>

由图论的基本定理可以推导出这样一个结论：无向图有偶数个度为奇数的顶点。证明也是显然的，在无向图 $G=(V,E)$ 中，设 $V_1$ 和 $V_2$ 分别是度为偶数和度为奇数的顶点的集合，因此

$$
    2m=\sum_{v\in V}\deg v=\sum_{v\in V_1}\deg v+\sum_{v\in V_2}\deg v
$$

由于 $2m$ 和 $\sum_{v\in V_1}\deg v$ 都是偶数，故 $\sum_{v\in V_2}\deg v$ 也是偶数，要满足这一条件，必须有偶数个度为奇数的顶点。

<br>

> **定义 4.1-6 有向图中的相邻**
>
> 当 $(u,v)$ 是带有有向图的图 $G$ 的边时，我们称 $u$ 邻接到 $v$，或者称 $v$ 从 $u$ 邻接。顶点 $u$ 称为 $(u,v)$ 的起点，顶点 $v$ 称为 $(u,v)$ 的终点，环的起点和终点是相同的

<br>

> **定义 4.1-7 入度和出度**
>
> 在带有有向图的图里，顶点 $v$ 的入度，记作 $\deg^-v$，是以 $v$ 作为终点的边数。顶点 $v$ 的出度，记作 $\deg^+v$，是以 $v$ 作为起点的边数，顶点上的环对这个顶点的入度和出度的贡献度都是 $1$

<br>

> **命题 4.1-2 有向图中的图论基本定理**
>
> 设 $G=(V,E)$ 是带有向图的图，于是
>
> $$
    \sum_{v\in V}\deg^-v=\sum_{v\in V}\deg^+v=\#(E)
>   $$
>
> 每条边都有一个起点和一个终点，所以在带有向边的图中，所有顶点的入度之和与所有顶点的出度之和相同，都等于图中的边数

<br>

> **定义 4.1-8 二部图**
>
> 若把简单无向图 $G$ 的顶点集分成两个不相交的非空集合 $V_1$ 和 $V_2$，使得图中的每一条边都连接 $V_1$ 中的一个顶点与 $V_2$ 中的一个顶点（即没有边连接 $V_1$ 中的两个顶点或 $V_2$ 中的两个顶点），则称 $G$ 为**二部图**或**二分图**（bipartite graph）。当此条件成立时，称 $(V_1,V_2)$ 为 $G$ 的顶点集的一个**二部划分**

<br>

既然我们定义了二部图的概念，就必须要给出判断一个图是否是二部图的比较好的方法。按照定义去判断是困难的，因为验证方式太多，我们给出下面这个命题：

<br>

> **命题 4.1-3 二部图的判断方法**
>
> 一个简单无向图是二部图，当且仅当能够对图中的每个顶点赋予两种不同的颜色，并使得没有两个相邻的顶点被赋予相同的颜色

<br>

证明：
- 首先证明充分性，假设简单无向图 $G=(V,E)$ 是一个二部图，则 $V=V_1\cup V_2$，其中 $V_1$ 和 $V_2$ 是不相交的顶点集且 $E$ 中的每一条边都连接一个 $V_1$ 中的顶点和 $V_2$ 的顶点。如果对 $V_1$ 中的每个顶点染一种颜色而对 $V_2$ 中的每个顶点染另一种颜色，由于 $V_1$ 内部和 $V_2$ 内部都没有边，所以没有相邻的顶点被赋予相同的颜色；
- 接着证明必要性，假设可以仅用两种颜色对图中的顶点着色，令 $V_1$ 为其中一种颜色的顶点集，$V_2$ 为另一种颜色的顶点集，则 $V_1\cap V_2=\emptyset$ 并且 $V_1\cup V_2=V$。此外，每条边都连接一个 $V_1$ 中的顶点和 $V_2$ 中的顶点，且 $V_1$ 和 $V_2$ 内部没有边相连，则 $G=(V,E)$ 是二部图。

<br>

二部图可以用于某些场景的建模，例如考虑一个组里有 $m$ 个员工，需要完成 $n$ 种不同的工作，其中 $m\geq n$，每个员工都受过相关培训，能够完成这 $n$ 个工作种的 $1$ 种或者多种。这个问题的建模可以考虑二部图，二部划分为 $(E,J)$，其中 $E$ 是员工的集合，$J$ 是工作的集合。这里的目的是找到合适的匹配使得每个工作都能分配给一个员工，并且没有一个员工被分配的工作多于一个。为描述这个问题的解决方法，我们给出匹配的概念：

<br>

> **定义 4.1-9 匹配**
>
> 在简单无向图 $G=(V,E)$ 中的一个匹配 $M$ 是边集 $E$ 的子集，该子集中没有两条边关联相同的顶点。换句话说 $M\subseteq E$，并且若 $(s,t),(u,v)\in M$，则 $s,t,u,v$ 是不同的顶点。若一个顶点是匹配 $M$ 中的一条边的端点，则称该顶点在 $M$ 中被匹配，否则称未被匹配。
> 
> 包含最多边数的一个匹配称为**最大匹配**。
>
> 设二部图 $G=(V,E)$ 的二部划分为 $(V_1,V_2)$，二部图的一个匹配为 $M$，若 $V_1$ 中的每个顶点都是匹配中边的端点或者满足
>
> $$
    \#(M)=\#(V_1)
>   $$
>
> 则称匹配 $M$ 是从 $V_1$ 到 $V_2$ 的**完全匹配**

<br>

下面的 Hall 定理给出了存在完全匹配的充分必要条件：

<br>

> **命题 4.1-4 Hall 定理**
>
> 带有二部划分 $(V_1,V_2)$ 的二部图 $G=(V,E)$ 中有一个从 $V_1$ 到 $V_2$ 的完全匹配，当且仅当对于 $V_1$ 的所有子集 $A$，有
>
> $$
    \#(N(A))\geq\#(A)
>   $$

<br>

证明：
- 首先证明较为简单的充分性：假设从 $V_1$ 到 $V_2$ 存在一个完全匹配 $M$，设$A\subseteq V_1$，对于 $A$ 中的每个顶点 $v$，在 $M$ 中存在一条边连接 $v$ 和 $V_2$ 中的一个顶点，因此在 $V_2$ 中与 $A$ 中顶点相邻的顶点个数至少与 $A$ 中的顶点一样多，因此

    $$
        \#(N(A))\geq\#(A)
    $$

- 接着证明更为复杂的必要性，我们将使用强归纳法进行证明：
  - 若 $$ \#(V_1)=1 $$，则 $V_1$ 只包含一个顶点 $v_0$，因为

    $$
            \#(N(\{v_0\}))\geq\#(\{v_0\})=1
    $$

    所以至少有一条边连接顶点 $v_0$ 和一个顶点 $w_0\in V_2$，任何这样的边都是从 $V_1$ 到 $V_2$ 的完全匹配；
  - 归纳假设：令 $k$ 为一个正整数，若 $G=(V,E)$ 是带有二部划分 $(V_1,V_2)$ 的二部图，且 $$ \#(V_1)=j\leq k $$，对于所有的 $A\subseteq V_1$ 满足 $$ \#(N(A))\geq\#(A) $$，就存在一个从 $V_1$ 到 $V_2$ 的完全匹配；
  - 假设 $H=(W,F)$ 是由二部划分 $(W_1,W_2)$ 构成的二部图且 $$ \#(W_1)=k+1 $$，我们只需要考虑两种情况：

    第一种情况：假设对所有的整数 $j$，且 $1\leq j\leq k$ 时，$W_1$ 中每个含有 $j$ 个元素的子集中的顶点都至少与 $W_2$ 中的 $j+1$ 个顶点相邻。选择一个顶点 $v\in W_1$ 和一个元素 $$ w\in N(\{v\}) $$，根据归纳假设知一定存在这样的 $v$ 和 $w$。从 $H$ 中删除 $v$ 和 $w$ 以及所有与它们相关联的边，由此可以得到二部划分为 $$ (W_1-\{v\},W_2-\{w\}) $$ 的二部图 $H'$，因为 $$ \#(W_1-\{v\})=k $$，根据归纳假设可知存在一个从 $$ W_1-\{v\} $$ 到 $$ W_2-\{w\}$$ 的完全匹配。在这个匹配中加入刚才删去的边集和点集（删去的边集也是一个完全匹配），就得到一个从 $W_1$ 到 $W_2$ 的完全匹配。

    第二种情况：假设对所有的整数 $j$，且 $1\leq j\leq k$ 时，存在一个含有 $j$ 个元素的子集 $W_1'$，且在 $W_2$ 中恰有 $j$ 个邻居和这些顶点相邻，令 $W_2'=N(W_1')$，根据归纳假设可知存在一个从 $W_1'$ 到 $W_2'$ 的完全匹配，从 $W_1$ 和 $W_2$ 中删除这 $2j$ 个顶点以及与它们相关联的边，就得到一个新的二部图 $K$，其二部划分为 $(W_1-W_1',W_2-W_2')$。
    
    我们先证明对于 $W_1-W_1'$ 的所有子集 $A$，都有

    $$
        \#(N(A))\geq\#(A)
    $$

    使用反证法证明这个结论。假设结论不成立，设存在一个 $W_1-W_1'$ 的含有 $t$ 个顶点的子集 $P$，其中 $1\leq t\leq k+1-j$，并且这个子集中的顶点在 $W_2-W_2'$ 中的相邻顶点小于 $t$ 个。令 $Q$ 是包含 $j+t$ 个顶点的 $W_1$ 的子集，该子集包含 $P$ 中的 $t$ 个顶点和我们从 $W_1$ 中移除的 $j$ 个顶点，$Q$ 在 $W_2$ 中的邻居有小于 $j+t$ 的顶点数，这与对任意的 $Q\subseteq W_1$ 都有 $$ \#(N(Q))\geq\#(Q) $$ 矛盾。

    因此根据归纳假设，二部图 $K$ 有完全匹配，加上我们删去的边集和点集（删去的边集也是一个完全匹配），就得到一个从 $W_1$ 到 $W_2$ 的完全匹配。

    根据强归纳法即可证明必要性成立。

综上所述，Hall 定理成立。

<br>

> **定义 4.1-10 子图与真子图**
>
> 图 $G=(V,E)$ 的子图（subgraph）是图 $H=(W,F)$，其中 $W\subseteq V$ 且 $F\subseteq E$。若 $H\neq G$，则称图 $H$ 是图 $G$ 的真子图（proper subgraph）

<br>

> **定义 4.1-11 导出子图和支撑子图**
>
> 若对子图 $H\subseteq G$，满足 $\forall u,v\in W$，只要 $(u,v)\in E$，就有 $(u,v)\in F$，则称 $H$ 是 $G$ 的导出子图（induced subgraph）。若 $V=W$，则称 $H$ 是 $G$ 的支撑子图（spanning subgraph）

<br>

> **定义 4.1-12 图的并集**
>
> 两个简单图 $G_1=(V_1,E_1)$ 和 $G_2=(V_2,E_2)$ 的并图是带有顶点集 $V_1\cup V_2$ 和边集 $E_1\cup E_2$ 的简单图。$G_1$ 和 $G_2$ 的并图可以表示为 $G_1\cup G_2$

<br>

> **定义 4.2-13 图的同构**
>
> 设 $G_1=(V_1,E_1)$ 和 $G_2=(V_2,E_2)$ 是简单图，若存在从 $V_1$ 到 $V_2$ 的双射 $f$，且 $f$ 具有以下性质：对 $V_1$ 中任意的顶点 $a$ 和 $b$ 来说，$a$ 和 $b$ 在 $G_1$ 中相邻当且仅当 $f(a)$ 和 $f(b)$ 在 $G_2$ 中相邻，则称 $G_1$ 和 $G_2$ 是同构的（isomorphic），这样的映射 $f$ 称为同构映射（isomorphism）

<br>

说明两个图是否同构是困难的，但是说明两个图是否不同构是相对容易的，如果能找到某个属性，两个图中只有一个图具有这个属性，由于这个属性应该在同构映射下保持不变，所以这说明了这两个图不同构。这种在同构映射下保持不变的性质称为**图形不变量**，这些性质比如有顶点数、边数以及顶点的度。但是，即使这些不变量都相同时，也不一定说明两个图同构。目前没有已知的用来判定简单图是否同构的不变量集。

<br>

### 4.2 连通性

<br>

> **定义 4.2-1 无向图中的通路**
>
> 设 $n$ 是非负整数且 $G$ 是无向图。在 $G$ 中从 $u$ 到 $v$ 的长度为 $n$ 的通路（path）是 $G$ 的 $n$ 条边 $e_1,\cdots,e_n$ 的序列，其中存在 $x_0=u,\cdots,x_n=v$ 的顶点序列，使得对于 $i=1,\cdots,n$，$e_i$ 以 $x_{i-1}$ 和 $x_i$ 为端点。当这个图是简单无向图时，就用顶点序列 $x_0,\cdots,x_n$ 表示这条通路（简单图没有环，所以路径唯一被顶点序列唯一确定）。
>
> 若一条通路在相同的顶点开始和结束，并且长度不为 $0$，则称这条通路为回路（circuit）。把通路或者回路说成是经过顶点 $x_1,\cdots,x_{n-1}$ 或者遍历边 $e_1,\cdots,e_n$。若通路或者回路不重复地包含相同的边，则它是简单的

<br>

> **定义 4.2-2 有向图中的通路**
>
> 设 $n$ 是非负整数且 $G$ 是有向图。在 $G$ 中从 $u$ 到 $v$ 的长度为 $n$ 的通路是 $G$ 的边的序列 $e_1,\cdots,e_n$，使得 $f(e_1)=(x_0,x_1),\cdots,f(e_n)=(x_{n-1},x_n)$，其中 $x_0=u,x_n=v$。当有向图中没有多重边时，就用顶点序列 $x_0,\cdots,x_n$ 来表示这条通路。
> 
> 把在相同的顶点上开始和结束的长度不为 $0$ 的通路成为回路。若通路或回路不重复地包含相同的边，则把它称为简单的

<br>

上述两个定义只是给出了图中两个顶点之间的连通性，接下去将给出整个图的连通性及和其有关的定理。

<br>

> **定义 4.2-3 无向图的连通性**
>
> 若无向图中每一对不同的顶点之间都有通路，则称该图是连通的（connected），否则称为不连通的

<br>

> **命题 4.2-1 连通无向图的性质**
>
> 在连通无向图的每一对不同顶点之间都存在简单通路（注意是简单的）

<br>

证明：设 $u$ 和 $v$ 是连通无向图 $G=(V,E)$ 的两个不同的顶点。由于 $G$ 是连通的，故 $u$ 和 $v$ 之间至少存在一条通路。设 $x_0,\cdots,x_n$ 是长度最短的通路，其中 $x_0=u,x_n=v$。假设其不是简单的，那么存在正整数 $0\leq i<j\leq n$ 使得 $x_i=x_j$。通过删除顶点序列 $x_i,x_{i+1},\cdots,x_j$ 所对应的边可以得到更短的通路。重复此操作直到通路为简单的，连通无向图保证了通路长度不会减为 $0$。

<br>

> **定义 4.2-4 连通分支**
>
> 图 $G$ 的连通分支（connected component）是图 $G$ 的连通子图，且该子图不是另一个子图的真子图，这意味着连通分支是图 $G$ 的极大连通子图

<br>

> **定义 4.2-5 割点和割边**
>
> 删除图 $G$ 中的一个顶点和它所关联的边，就能产生比原图具有更多连通分支的子图。把这种点称为割点（cut vertices）。从连通图里删除割点，可以得到不连通的子图。
>
> 删除图 $G$ 中的一条边，就产生比原图具有更多连通分支的子图，这样的边称为割边（cut edge）或桥（bridge）

<br>

我们考虑一个图的点连通性。并不是所有图都有割点（例如对于完全图来说，删除任何一个点都不会破坏连通性）。不含割点的图称为不可分割图，它比有割点的图具有更好的连通性。

<br>

> **定义 4.2-6 点连通度**
>
> 设 $V'$ 是图 $G$ 的点集的子集，若 $G-V'$ 是不连通的，则称 $V'$ 是点割集（vertex cut）。除了完全图外，所有连通图都有一个点割集。定义非完全图的点连通度（vertex connectivity）为最小点割集的顶点数，记为 $\kappa(G)$。对于完全图，由于它没有点割集，我们特殊定义 $\kappa(K_n)=n-1$，这是删除 $n-1$ 个顶点剩下单点的含义

<br>

对于一个图 $G$ 来说，点连通度 $\kappa(G)$ 指的是使 $G$ 变成不连通的图或只含有一个顶点的图所需删除的最小的顶点数。$\kappa(G)$ 越大，我们认为 $G$ 的连通性越好。不连通的图和 $K_1$ 具有 $\kappa(G)=0$。若 $G$ 有 $n$ 个顶点，则

$$
    0\leq\kappa(G)\leq n-1
$$

若 $\kappa(G)\geq k$，则我们称图为 $k$ 连通的或者 $k$ 顶点-连通的。

<br>

上述文字讨论了与割点有关的点连通度，与之相应的，我们考虑与割边有关的边连通度。我们可以通过把连通图 $G=(V,E)$ 变成不连通的所需要删除的最小边数来度量边连通度这一概念。

<br>

> **定义 4.2-7 边连通度**
>
> 设 $E'$ 是图 $G$ 的边集的子集，若 $G-E'$ 是不连通的，则称 $E'$ 是边割集（edge cut）。定义图的的边连通度（edge connectivity）为最小边割集的边数，记为 $\lambda(G)$，对于不连通的图或者只有一个顶点的图，$\lambda(G)=0$。若 $G$ 是一个有 $n$ 个点的图，则 $0\leq\lambda(G)\leq n-1$

<br>

当 $G=(V,E)$ 是一个至少含有 $3$ 个顶点的非完全连通图时，图 $G$ 中顶点的最小度是图 $G$ 的点连通度和边连通度的上界，这是因为最多只需要移除度最小的点的邻居或者以它为端点的边就可以使图 $G$ 是不连通的。

<br>

对于一个边连通度为 $\lambda(G)$ 的图 $G$，其中每一条边都选择一个端点就能组成一个图 $G$ 的点割集。根据以上两条事实，可以得到 Whitney 不等式：

$$
    \kappa(G)\leq\lambda(G)\leq\min_{v\in V}\deg(v)
$$

<br>

> **定义 4.2-8 有向图的连通性**
>
> 若对于有向图中的任意顶点 $a$ 和 $b$，都有从 $a$ 到 $b$ 和从 $b$ 到 $a$ 的回路，则称该有向图是强连通的（strongly connected）。若在有向图退化后的无向图中，任何两个顶点间都有通路，则该有向图是弱连通的（weakly connected）

